###############################################################################
#
# IAR C/C++ Compiler V2.10.4.157 for STM8                 22/Dec/2016  20:03:31
# Copyright 2010-2015 IAR Systems AB.
#
#    Source file  =  
#        E:\Github
#        Project\STM8L151K4T6_Oil_Can_Drone\STM8L15x_StdPeriph_Driver\src\stm8l15x_tim3.c
#    Command line =  
#        "E:\Github
#        Project\STM8L151K4T6_Oil_Can_Drone\STM8L15x_StdPeriph_Driver\src\stm8l15x_tim3.c"
#        -e -Ol --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_cross_call --debug --code_model medium --data_model medium -o
#        "E:\Github Project\STM8L151K4T6_Oil_Can_Drone\Debug\Obj\"
#        --dlib_config "E:\My Program\IAR_STM8-7.0\stm8\LIB\dlstm8mmf.h" -D
#        STM8L15X_MD -lcN "E:\Github
#        Project\STM8L151K4T6_Oil_Can_Drone\Debug\List\" -I "E:\Github
#        Project\STM8L151K4T6_Oil_Can_Drone\" -I "E:\Github
#        Project\STM8L151K4T6_Oil_Can_Drone\STM8L15x_StdPeriph_Driver\inc\" -I
#        "E:\Github Project\STM8L151K4T6_Oil_Can_Drone\APP\" -I "E:\Github
#        Project\STM8L151K4T6_Oil_Can_Drone\BSP\" --vregs 16
#    List file    =  
#        E:\Github
#        Project\STM8L151K4T6_Oil_Can_Drone\Debug\List\stm8l15x_tim3.lst
#    Object file  =  
#        E:\Github Project\STM8L151K4T6_Oil_Can_Drone\Debug\Obj\stm8l15x_tim3.o
#
###############################################################################

E:\Github Project\STM8L151K4T6_Oil_Can_Drone\STM8L15x_StdPeriph_Driver\src\stm8l15x_tim3.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm8l15x_tim3.c
      4            * @author  MCD Application Team
      5            * @version V1.4.0
      6            * @date    09/24/2010
      7            * @brief   This file provides all the TIM3 firmware functions.
      8            ******************************************************************************
      9            * @copy
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2010 STMicroelectronics</center></h2>
     19            */
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "stm8l15x_tim3.h"
     23          
     24          /** @addtogroup STM8L15x_StdPeriph_Driver
     25            * @{
     26            */
     27          
     28          /* Private typedef -----------------------------------------------------------*/
     29          /* Private define ------------------------------------------------------------*/
     30          /* Private macro -------------------------------------------------------------*/
     31          /* Private variables ---------------------------------------------------------*/
     32          /* Private function prototypes -----------------------------------------------*/
     33          static void TI1_Config(TIM3_ICPolarity_TypeDef TIM3_ICPolarity,
     34                                 TIM3_ICSelection_TypeDef TIM3_ICSelection,
     35                                 uint8_t TIM3_ICFilter);
     36          static void TI2_Config(TIM3_ICPolarity_TypeDef TIM3_ICPolarity,
     37                                 TIM3_ICSelection_TypeDef TIM3_ICSelection,
     38                                 uint8_t TIM3_ICFilter);
     39          
     40          
     41          /**
     42            * @addtogroup TIM3_Public_Functions
     43            * @{
     44            */
     45          
     46          /**
     47            * @brief  Deinitializes the TIM3 peripheral registers to their default reset values.
     48            * @param  None
     49            * @retval None
     50            */
     51          void TIM3_DeInit(void)
     52          {
     53            TIM3->CR1 = TIM_CR1_RESET_VALUE;
     54            TIM3->CR2 = TIM_CR2_RESET_VALUE;
     55            TIM3->SMCR = TIM_SMCR_RESET_VALUE;
     56            TIM3->ETR = TIM_ETR_RESET_VALUE;
     57            TIM3->IER = TIM_IER_RESET_VALUE;
     58            TIM3->SR2 = TIM_SR2_RESET_VALUE;
     59          
     60            /* Disable channels */
     61            TIM3->CCER1 = TIM_CCER1_RESET_VALUE;
     62            /* Configure channels as inputs: it is necessary if lock level is equal to 2 or 3 */
     63            TIM3->CCMR1 = 0x01;/* TIM3_ICxSource_TIxFPx */
     64            TIM3->CCMR2 = 0x01;/* TIM3_ICxSource_TIxFPx */
     65          
     66            /* Then reset channel registers: it also works if lock level is equal to 2 or 3 */
     67            TIM3->CCER1 = TIM_CCER1_RESET_VALUE;
     68            TIM3->CCMR1 = TIM_CCMR1_RESET_VALUE;
     69            TIM3->CCMR2 = TIM_CCMR2_RESET_VALUE;
     70          
     71            TIM3->CNTRH = TIM_CNTRH_RESET_VALUE;
     72            TIM3->CNTRL = TIM_CNTRL_RESET_VALUE;
     73          
     74            TIM3->PSCR = TIM_PSCR_RESET_VALUE;
     75          
     76            TIM3->ARRH = TIM_ARRH_RESET_VALUE;
     77            TIM3->ARRL = TIM_ARRL_RESET_VALUE;
     78          
     79            TIM3->CCR1H = TIM_CCR1H_RESET_VALUE;
     80            TIM3->CCR1L = TIM_CCR1L_RESET_VALUE;
     81            TIM3->CCR2H = TIM_CCR2H_RESET_VALUE;
     82            TIM3->CCR2L = TIM_CCR2L_RESET_VALUE;
     83          
     84          
     85            TIM3->OISR = TIM_OISR_RESET_VALUE;
     86            TIM3->EGR = 0x01;/* TIM_EGR_UG */
     87            TIM3->BKR = TIM_BKR_RESET_VALUE;
     88            TIM3->SR1 = TIM_SR1_RESET_VALUE;
     89          }
     90          
     91          /**
     92            * @brief  Initializes the TIM3 Time Base Unit according to the specified parameters.
     93            * @param  TIM3_Prescaler : This parameter can be any member of the @Ref TIM3_Prescaler_TypeDef enumeration.
     94            * @param  TIM3_CounterMode : This parameter can be any member of the @Ref TIM3_CounterMode_TypeDef enumeration.
     95            * @param  TIM3_Period : This parameter must be a value between 0x0000 and 0xFFFF.
     96            * @retval None
     97            */
     98          
     99          void TIM3_TimeBaseInit(TIM3_Prescaler_TypeDef TIM3_Prescaler,
    100                                 TIM3_CounterMode_TypeDef TIM3_CounterMode,
    101                                 uint16_t TIM3_Period)
    102          {
    103          
    104            assert_param(IS_TIM3_PRESCALER(TIM3_Prescaler));
    105            assert_param(IS_TIM3_COUNTER_MODE(TIM3_CounterMode));
    106          
    107          
    108          
    109            /* Set the Autoreload value */
    110            TIM3->ARRH = (uint8_t)(TIM3_Period >> 8) ;
    111            TIM3->ARRL = (uint8_t)(TIM3_Period);
    112          
    113            /* Set the Prescaler value */
    114            TIM3->PSCR = (uint8_t)(TIM3_Prescaler);
    115          
    116            /* Select the Counter Mode */
    117            TIM3->CR1 &= (uint8_t)((uint8_t)(~TIM_CR1_CMS)) & ((uint8_t)(~TIM_CR1_DIR));
    118            TIM3->CR1 |= (uint8_t)(TIM3_CounterMode);
    119          
    120            /* Generate an update event to reload the Prescaler value immediately */
    121            TIM3->EGR = TIM3_EventSource_Update;
    122          }
    123          
    124          /**
    125            * @brief Initializes the TIM3 Channel1 according to the specified parameters.
    126            * @param  TIM3_OCMode : This parameter can be any member of the @Ref TIM3_OCMode_TypeDef enumeration.
    127            * @param  TIM3_OutputState : This parameter can be any member of the @Ref TIM3_OutputState_TypeDef enumeration.
    128            * @param  TIM3_Pulse : This parameter must be a value between 0x0000 and 0xFFFF.
    129            * @param  TIM3_OCPolarity : This parameter can be any member of the @Ref TIM3_OCPolarity_TypeDef enumeration.
    130            * @param  TIM3_OCIdleState : This parameter can be any member of the @Ref TIM3_OCIdleState_TypeDef  enumeration.
    131            * @retval None
    132            */
    133          void TIM3_OC1Init(TIM3_OCMode_TypeDef TIM3_OCMode,
    134                            TIM3_OutputState_TypeDef TIM3_OutputState,
    135                            uint16_t TIM3_Pulse,
    136                            TIM3_OCPolarity_TypeDef TIM3_OCPolarity,
    137                            TIM3_OCIdleState_TypeDef TIM3_OCIdleState)
    138          {
    139            uint8_t tmpccmr1 = 0;
    140          
    141            /* Check the parameters */
    142            assert_param(IS_TIM3_OC_MODE(TIM3_OCMode));
    143            assert_param(IS_TIM3_OUTPUT_STATE(TIM3_OutputState));
    144            assert_param(IS_TIM3_OC_POLARITY(TIM3_OCPolarity));
    145            assert_param(IS_TIM3_OCIDLE_STATE(TIM3_OCIdleState));
    146          
    147            tmpccmr1 = TIM3->CCMR1;
    148          
    149            /* Disable the Channel 1: Reset the CCE Bit */
    150            TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC1E);
    151            /* Reset the Output Compare Bits */
    152            tmpccmr1 &= (uint8_t)(~TIM_CCMR_OCM);
    153          
    154            /* Set the Ouput Compare Mode */
    155            tmpccmr1 |= (uint8_t)TIM3_OCMode;
    156          
    157            TIM3->CCMR1 = tmpccmr1;
    158          
    159            /* Set the Output State */
    160            if (TIM3_OutputState == TIM3_OutputState_Enable)
    161            {
    162              TIM3->CCER1 |= TIM_CCER1_CC1E;
    163            }
    164            else
    165            {
    166              TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC1E);
    167            }
    168          
    169            /* Set the Output Polarity */
    170            if (TIM3_OCPolarity == TIM3_OCPolarity_Low)
    171            {
    172              TIM3->CCER1 |= TIM_CCER1_CC1P;
    173            }
    174            else
    175            {
    176              TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC1P);
    177            }
    178          
    179            /* Set the Output Idle state */
    180            if (TIM3_OCIdleState == TIM3_OCIdleState_Set)
    181            {
    182              TIM3->OISR |= TIM_OISR_OIS1;
    183            }
    184            else
    185            {
    186              TIM3->OISR &= (uint8_t)(~TIM_OISR_OIS1);
    187            }
    188          
    189            /* Set the Pulse value */
    190            TIM3->CCR1H = (uint8_t)(TIM3_Pulse >> 8);
    191            TIM3->CCR1L = (uint8_t)(TIM3_Pulse);
    192          }
    193          
    194          /**
    195            * @brief  Initializes the TIM3 Channel2 according to the specified parameters.
    196            * @param  TIM3_OCMode : This parameter can be any member of the @Ref TIM3_OCMode_TypeDef enumeration.
    197            * @param  TIM3_OutputState : This parameter can be any member of the @Ref TIM3_OutputState_TypeDef enumeration.
    198            * @param  TIM3_Pulse : This parameter must be a value between 0x0000 and 0xFFFF.
    199            * @param  TIM3_OCPolarity : This parameter can be any member of the @Ref TIM3_OCPolarity_TypeDef enumeration.
    200            * @param  TIM3_OCIdleState : This parameter can be any member of the @Ref TIM3_OCIdleState_TypeDef  enumeration.
    201            * @retval None
    202            */
    203          void TIM3_OC2Init(TIM3_OCMode_TypeDef TIM3_OCMode,
    204                            TIM3_OutputState_TypeDef TIM3_OutputState,
    205                            uint16_t TIM3_Pulse,
    206                            TIM3_OCPolarity_TypeDef TIM3_OCPolarity,
    207                            TIM3_OCIdleState_TypeDef TIM3_OCIdleState)
    208          {
    209            uint8_t tmpccmr2 = 0;
    210          
    211            /* Check the parameters */
    212            assert_param(IS_TIM3_OC_MODE(TIM3_OCMode));
    213            assert_param(IS_TIM3_OUTPUT_STATE(TIM3_OutputState));
    214            assert_param(IS_TIM3_OC_POLARITY(TIM3_OCPolarity));
    215            assert_param(IS_TIM3_OCIDLE_STATE(TIM3_OCIdleState));
    216          
    217            tmpccmr2 = TIM3->CCMR2;
    218          
    219            /* Disable the Channel 2: Reset the CCE Bit */
    220            TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC2E);
    221          
    222            /* Reset the Output Compare Bits */
    223            tmpccmr2 &= (uint8_t)(~TIM_CCMR_OCM);
    224          
    225            /* Set the Ouput Compare Mode */
    226            tmpccmr2 |= (uint8_t)TIM3_OCMode;
    227          
    228            TIM3->CCMR2 = tmpccmr2;
    229          
    230            /* Set the Output State */
    231            if (TIM3_OutputState == TIM3_OutputState_Enable)
    232            {
    233              TIM3->CCER1 |= TIM_CCER1_CC2E;
    234            }
    235            else
    236            {
    237              TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC2E);
    238            }
    239          
    240            /* Set the Output Polarity */
    241            if (TIM3_OCPolarity == TIM3_OCPolarity_Low)
    242            {
    243              TIM3->CCER1 |= TIM_CCER1_CC2P;
    244            }
    245            else
    246            {
    247              TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC2P);
    248            }
    249          
    250          
    251            /* Set the Output Idle state */
    252            if (TIM3_OCIdleState == TIM3_OCIdleState_Set)
    253            {
    254              TIM3->OISR |= TIM_OISR_OIS2;
    255            }
    256            else
    257            {
    258              TIM3->OISR &= (uint8_t)(~TIM_OISR_OIS2);
    259            }
    260          
    261            /* Set the Pulse value */
    262            TIM3->CCR2H = (uint8_t)(TIM3_Pulse >> 8);
    263            TIM3->CCR2L = (uint8_t)(TIM3_Pulse);
    264          }
    265          
    266          /**
    267            * @brief  Configures the Break feature, dead time, Lock level, the OSSI,
    268            * and the AOE(automatic output enable).
    269            * @param  TIM3_OSSIState : Off-State Selection for Idle mode states.
    270            *   This parameter can be any member of the @Ref TIM3_OSSIState_TypeDef enumeration.
    271            * @param  TIM3_LockLevel : Lock level.
    272            *   This parameter can be any member of the @Ref TIM3_LockLevel_TypeDef enumeration.
    273            * @param  TIM3_BreakState : Break Input enable/disable .
    274            *   This parameter can be any member of the @Ref TIM3_BreakState_TypeDef enumeration.
    275            * @param  TIM3_BreakPolarity : Break Polarity.
    276            *   This parameter can be any member of the @Ref TIM3_BreakPolarity_TypeDef enumeration.
    277            * @param  TIM3_AutomaticOutput : TIM3 AOE Bit Set/Reset .
    278            *   This parameter can be anymember of the @Ref TIM3_AutomaticOutput_TypeDef enumeration.
    279            * @retval None
    280            */
    281          void TIM3_BKRConfig(TIM3_OSSIState_TypeDef TIM3_OSSIState,
    282                              TIM3_LockLevel_TypeDef TIM3_LockLevel,
    283                              TIM3_BreakState_TypeDef TIM3_BreakState,
    284                              TIM3_BreakPolarity_TypeDef TIM3_BreakPolarity,
    285                              TIM3_AutomaticOutput_TypeDef TIM3_AutomaticOutput)
    286          {
    287            /* Check the parameters */
    288            assert_param(IS_TIM3_OSSI_STATE(TIM3_OSSIState));
    289            assert_param(IS_TIM3_LOCK_LEVEL(TIM3_LockLevel));
    290            assert_param(IS_TIM3_BREAK_STATE(TIM3_BreakState));
    291            assert_param(IS_TIM3_BREAK_POLARITY(TIM3_BreakPolarity));
    292            assert_param(IS_TIM3_AUTOMATIC_OUTPUT_STATE(TIM3_AutomaticOutput));
    293          
    294          
    295          
    296            /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSI State,
    297            the dead time value and the Automatic Output Enable Bit */
    298          
    299            TIM3->BKR = (uint8_t)((uint8_t)((uint8_t)((uint8_t)((uint8_t)TIM3_OSSIState | (uint8_t)TIM3_LockLevel) | \
    300                                            (uint8_t)((uint8_t)TIM3_BreakState | (uint8_t)TIM3_BreakPolarity)) | \
    301                                            TIM3_AutomaticOutput));
    302          }
    303          
    304          /**
    305            * @brief  Initializes the TIM3 peripheral according to the specified parameters.
    306            * @param  TIM3_Channel : This parameter can be any member of the @Ref TIM3_Channel_TypeDef enumeration.
    307            * @param  TIM3_ICPolarity : This parameter can be any member of the @Ref TIM3_ICPolarity_TypeDef enumeration.
    308            * @param  TIM3_ICSelection : This parameter can be any member of the @Ref TIM3_ICSelection_TypeDef enumeration.
    309            * @param  TIM3_ICPrescaler : This parameter can be any member of the @Ref TIM3_ICPSC_TypeDef enumeration.
    310            * @param  TIM3_ICFilter : This parameter must be a value between 0x00 and 0x0F.
    311            * @retval None
    312            */
    313          void TIM3_ICInit(TIM3_Channel_TypeDef TIM3_Channel,
    314                           TIM3_ICPolarity_TypeDef TIM3_ICPolarity,
    315                           TIM3_ICSelection_TypeDef TIM3_ICSelection,
    316                           TIM3_ICPSC_TypeDef TIM3_ICPrescaler,
    317                           uint8_t TIM3_ICFilter)
    318          {
    319            /* Check the parameters */
    320            assert_param(IS_TIM3_CHANNEL(TIM3_Channel));
    321          
    322            if (TIM3_Channel == TIM3_Channel_1)
    323            {
    324              /* TI1 Configuration */
    325              TI1_Config(TIM3_ICPolarity, TIM3_ICSelection, TIM3_ICFilter);
    326          
    327              /* Set the Input Capture Prescaler value */
    328              TIM3_SetIC1Prescaler(TIM3_ICPrescaler);
    329            }
    330            else /* if (TIM3_Channel == TIM3_Channel_2) */
    331            {
    332              /* TI2 Configuration */
    333              TI2_Config(TIM3_ICPolarity, TIM3_ICSelection, TIM3_ICFilter);
    334              /* Set the Input Capture Prescaler value */
    335              TIM3_SetIC2Prescaler(TIM3_ICPrescaler);
    336            }
    337          }
    338          
    339          /**
    340            * @brief  Configures the TIM3 peripheral in PWM Input Mode according to the
    341            * specified parameters.
    342            * @param  TIM3_Channel : This parameter can be any member of the @Ref TIM3_Channel_TypeDef enumeration.
    343            * @param  TIM3_ICPolarity : This parameter can be any member of the @Ref TIM3_ICPolarity_TypeDef enumeration.
    344            * @param  TIM3_ICSelection : This parameter can be any member of the @Ref TIM3_ICSelection_TypeDef enumeration.
    345            * @param  TIM3_ICPrescaler : This parameter can be any member of the @Ref TIM3_ICPSC_TypeDef enumeration.
    346            * @param  TIM3_ICFilter : This parameter must be a value between 0x00 and 0x0F.
    347            * @retval None
    348            */
    349          void TIM3_PWMIConfig(TIM3_Channel_TypeDef TIM3_Channel,
    350                               TIM3_ICPolarity_TypeDef TIM3_ICPolarity,
    351                               TIM3_ICSelection_TypeDef TIM3_ICSelection,
    352                               TIM3_ICPSC_TypeDef TIM3_ICPrescaler,
    353                               uint8_t TIM3_ICFilter)
    354          {
    355            uint8_t icpolarity = TIM3_ICPolarity_Rising;
    356            uint8_t icselection = TIM3_ICSelection_DirectTI;
    357          
    358            /* Check the parameters */
    359            assert_param(IS_TIM3_CHANNEL(TIM3_Channel));
    360          
    361            /* Select the Opposite Input Polarity */
    362            if (TIM3_ICPolarity == TIM3_ICPolarity_Rising)
    363            {
    364              icpolarity = TIM3_ICPolarity_Falling;
    365            }
    366            else
    367            {
    368              icpolarity = TIM3_ICPolarity_Rising;
    369            }
    370          
    371            /* Select the Opposite Input */
    372            if (TIM3_ICSelection == TIM3_ICSelection_DirectTI)
    373            {
    374              icselection = TIM3_ICSelection_IndirectTI;
    375            }
    376            else
    377            {
    378              icselection = TIM3_ICSelection_DirectTI;
    379            }
    380          
    381            if (TIM3_Channel == TIM3_Channel_1)
    382            {
    383              /* TI1 Configuration */
    384              TI1_Config(TIM3_ICPolarity, TIM3_ICSelection, TIM3_ICFilter);
    385          
    386              /* Set the Input Capture Prescaler value */
    387              TIM3_SetIC1Prescaler(TIM3_ICPrescaler);
    388          
    389              /* TI2 Configuration */
    390              TI2_Config((TIM3_ICPolarity_TypeDef)icpolarity, (TIM3_ICSelection_TypeDef)icselection, TIM3_ICFilter);
    391          
    392              /* Set the Input Capture Prescaler value */
    393              TIM3_SetIC2Prescaler(TIM3_ICPrescaler);
    394            }
    395            else
    396            {
    397              /* TI2 Configuration */
    398              TI2_Config(TIM3_ICPolarity, TIM3_ICSelection, TIM3_ICFilter);
    399          
    400              /* Set the Input Capture Prescaler value */
    401              TIM3_SetIC2Prescaler(TIM3_ICPrescaler);
    402          
    403              /* TI1 Configuration */
    404              TI1_Config((TIM3_ICPolarity_TypeDef)icpolarity, (TIM3_ICSelection_TypeDef)icselection, TIM3_ICFilter);
    405          
    406              /* Set the Input Capture Prescaler value */
    407              TIM3_SetIC1Prescaler(TIM3_ICPrescaler);
    408            }
    409          }
    410          
    411          /**
    412            * @brief  Enables or disables the TIM3 peripheral.
    413            * @param NewState : The new state of the TIM3 peripheral.
    414            *   This parameter can be any of the @ref FunctionalState enumeration.
    415            * @retval None
    416            */
    417          void TIM3_Cmd(FunctionalState NewState)
    418          {
    419            /* Check the parameters */
    420            assert_param(IS_FUNCTIONAL_STATE(NewState));
    421          
    422            /* set or Reset the CEN Bit */
    423            if (NewState != DISABLE)
    424            {
    425              TIM3->CR1 |= TIM_CR1_CEN;
    426            }
    427            else
    428            {
    429              TIM3->CR1 &= (uint8_t)(~TIM_CR1_CEN);
    430            }
    431          }
    432          
    433          /**
    434            * @brief  Enables or disables the TIM3 peripheral Main Outputs.
    435            * @param NewState : The new state of the TIM3 peripheral.
    436            *   This parameter can be any of the @ref FunctionalState enumeration.
    437            * @retval None
    438            */
    439          void TIM3_CtrlPWMOutputs(FunctionalState NewState)
    440          {
    441            /* Check the parameters */
    442            assert_param(IS_FUNCTIONAL_STATE(NewState));
    443          
    444            /* Set or Reset the MOE Bit */
    445          
    446            if (NewState != DISABLE)
    447            {
    448              TIM3->BKR |= TIM_BKR_MOE ;
    449            }
    450            else
    451            {
    452              TIM3->BKR &= (uint8_t)(~TIM_BKR_MOE) ;
    453            }
    454          }
    455          /**
    456            * @brief  Enables or disables the specified TIM3 interrupts.
    457            * @param  TIM3_IT : Specifies the TIM3 interrupts sources to be enabled or disabled.
    458            *   This parameter can be any combination of the @ref TIM3_IT_TypeDef enumeration.
    459            * @param NewState : The new state of the TIM3 peripheral.
    460            *   This parameter can be any of the @ref FunctionalState enumeration.
    461            * @retval None
    462            */
    463          void TIM3_ITConfig(TIM3_IT_TypeDef TIM3_IT, FunctionalState NewState)
    464          {
    465            /* Check the parameters */
    466            assert_param(IS_TIM3_IT(TIM3_IT));
    467            assert_param(IS_FUNCTIONAL_STATE(NewState));
    468          
    469            if (NewState != DISABLE)
    470            {
    471              /* Enable the Interrupt sources */
    472              TIM3->IER |= (uint8_t)TIM3_IT;
    473            }
    474            else
    475            {
    476              /* Disable the Interrupt sources */
    477              TIM3->IER &= (uint8_t)(~(uint8_t)TIM3_IT);
    478            }
    479          }
    480          
    481          /**
    482            * @brief  Enables or disables the TIMx’s DMA Requests.
    483            * @param  TIM3_DMASources: specifies the DMA Request sources.
    484            *   This parameter can be any combination of the @ref TIM3_DMASource_TypeDef enumeration.
    485            * @param NewState: new state of the DMA Request sources. This parameter can be: ENABLE or DISABLE.
    486            * @retval None
    487            */
    488          void TIM3_DMACmd(TIM3_DMASource_TypeDef TIM3_DMASource, FunctionalState NewState)
    489          {
    490            /* Check the parameters */
    491            assert_param(IS_FUNCTIONAL_STATE(NewState));
    492            assert_param(IS_TIM3_DMA_SOURCE(TIM3_DMASource));
    493          
    494            if (NewState != DISABLE)
    495            {
    496              /* Enable the DMA sources */
    497              TIM3->DER |= TIM3_DMASource;
    498            }
    499            else
    500            {
    501              /* Disable the DMA sources */
    502              TIM3->DER &= (uint8_t)~TIM3_DMASource;
    503            }
    504          }
    505          /**
    506            * @brief  Enables the TIM3 internal Clock.
    507            * @par Parameters:
    508            * None
    509            * @retval None
    510            */
    511          void TIM3_InternalClockConfig(void)
    512          {
    513            /* Disable slave mode to clock the prescaler directly with the internal clock */
    514            TIM3->SMCR &=  (uint8_t)(~TIM_SMCR_SMS);
    515          }
    516          
    517          /**
    518            * @brief  Configures the TIM3 External clock Mode1.
    519            * @param  TIM3_ExtTRGPrescaler : Specifies the external Trigger Prescaler.
    520            *   This parameter can be one of @ref TIM3_ExtTRGPSC_TypeDef enumeration.
    521            * @param  TIM3_ExtTRGPolarity : Specifies the external Trigger Polarity.
    522            *   This parameter can be one of @ref TIM3_ExtTRGPolarity_TypeDef enumeration.
    523            * @param ExtTRGFilter : Specifies the External Trigger Filter.
    524            *   This parameter must be a value between 0x00 and 0x0F
    525            * @retval None
    526            */
    527          void TIM3_ETRClockMode1Config(TIM3_ExtTRGPSC_TypeDef TIM3_ExtTRGPrescaler,
    528                                        TIM3_ExtTRGPolarity_TypeDef TIM3_ExtTRGPolarity,
    529                                        uint8_t ExtTRGFilter)
    530          {
    531            /* Configure the ETR Clock source */
    532            TIM3_ETRConfig(TIM3_ExtTRGPrescaler, TIM3_ExtTRGPolarity, ExtTRGFilter);
    533          
    534            /* Select the External clock mode1 */
    535            TIM3->SMCR &= (uint8_t)(~TIM_SMCR_SMS);
    536            TIM3->SMCR |= (uint8_t)(TIM3_SlaveMode_External1);
    537          
    538            /* Select the Trigger selection : ETRF */
    539            TIM3->SMCR &= (uint8_t)(~TIM_SMCR_TS);
    540            TIM3->SMCR |= (uint8_t)((TIM3_TRGSelection_TypeDef)TIM3_TRGSelection_ETRF);
    541          }
    542          
    543          /**
    544            * @brief  Configures the TIM3 External clock Mode2.
    545            * @param  TIM3_ExtTRGPrescaler : Specifies the external Trigger Prescaler.
    546            *   This parameter can be one of the @ref TIM3_ExtTRGPSC_TypeDef enumeration.
    547            * @param  TIM3_ExtTRGPolarity : Specifies the external Trigger Polarity.
    548            *   This parameter can be one of the @ref TIM3_ExtTRGPolarity_TypeDef enumeration.
    549            * @param ExtTRGFilter : Specifies the External Trigger Filter.
    550            *   This parameter must be a value between 0x00 and 0x0F
    551            * @retval None
    552            */
    553          void TIM3_ETRClockMode2Config(TIM3_ExtTRGPSC_TypeDef TIM3_ExtTRGPrescaler,
    554                                        TIM3_ExtTRGPolarity_TypeDef TIM3_ExtTRGPolarity,
    555                                        uint8_t ExtTRGFilter)
    556          {
    557            /* Configure the ETR Clock source */
    558            TIM3_ETRConfig(TIM3_ExtTRGPrescaler, TIM3_ExtTRGPolarity, ExtTRGFilter);
    559          
    560            /* Enable the External clock mode2 */
    561            TIM3->ETR |= TIM_ETR_ECE ;
    562          }
    563          
    564          /**
    565            * @brief  Configures the TIM3 External Trigger.
    566            * @param  TIM3_ExtTRGPrescaler : Specifies the external Trigger Prescaler.
    567            *   This parameter can be one of the @ref TIM3_ExtTRGPSC_TypeDef enumeration.
    568            * @param  TIM3_ExtTRGPolarity : Specifies the external Trigger Polarity.
    569            *   This parameter can be one of the @ref TIM3_ExtTRGPolarity_TypeDef enumeration.
    570            * @param ExtTRGFilter : Specifies the External Trigger Filter.
    571            *   This parameter must be a value between 0x00 and 0x0F
    572            * @retval None
    573            */
    574          void TIM3_ETRConfig(TIM3_ExtTRGPSC_TypeDef TIM3_ExtTRGPrescaler,
    575                              TIM3_ExtTRGPolarity_TypeDef TIM3_ExtTRGPolarity,
    576                              uint8_t ExtTRGFilter)
    577          {
    578            /* Check the parameters */
    579            assert_param(IS_TIM3_EXT_PRESCALER(TIM3_ExtTRGPrescaler));
    580            assert_param(IS_TIM3_EXT_POLARITY(TIM3_ExtTRGPolarity));
    581            assert_param(IS_TIM3_EXT_FILTER(ExtTRGFilter));
    582          
    583            /* Set the Prescaler, the Filter value and the Polarity */
    584            TIM3->ETR |= (uint8_t)((uint8_t)((uint8_t)TIM3_ExtTRGPrescaler | (uint8_t)TIM3_ExtTRGPolarity)
    585                                   | (uint8_t)ExtTRGFilter);
    586          }
    587          
    588          /**
    589            * @brief  Configures the TIM3 Trigger as External Clock.
    590            * @param  TIM3_TIxExternalCLKSource : Specifies Trigger source.
    591            *   This parameter can be one of the @ref TIM3_TIxExternalCLK1Source_TypeDef enumeration.
    592            * @param  TIM3_ICPolarity : Specifies the TIx Polarity.
    593            *   This parameter can be @ref TIM3_ICPolarity_TypeDef enumeration.
    594            * @param ICFilter : Specifies the filter value.
    595            *   This parameter must be a value between 0x00 and 0x0F
    596            * @retval None
    597            */
    598          void TIM3_TIxExternalClockConfig(TIM3_TIxExternalCLK1Source_TypeDef TIM3_TIxExternalCLKSource,
    599                                           TIM3_ICPolarity_TypeDef TIM3_ICPolarity,
    600                                           uint8_t ICFilter)
    601          {
    602            /* Check the parameters */
    603            assert_param(IS_TIM3_TIXCLK_SOURCE(TIM3_TIxExternalCLKSource));
    604            assert_param(IS_TIM3_IC_POLARITY(TIM3_ICPolarity));
    605            assert_param(IS_TIM3_IC_FILTER(ICFilter));
    606          
    607            /* Configure the TIM3 Input Clock Source */
    608            if (TIM3_TIxExternalCLKSource == TIM3_TIxExternalCLK1Source_TI2)
    609            {
    610              TI2_Config(TIM3_ICPolarity, TIM3_ICSelection_DirectTI, ICFilter);
    611            }
    612            else
    613            {
    614              TI1_Config(TIM3_ICPolarity, TIM3_ICSelection_DirectTI, ICFilter);
    615            }
    616          
    617            /* Select the Trigger source */
    618            TIM3_SelectInputTrigger((TIM3_TRGSelection_TypeDef)TIM3_TIxExternalCLKSource);
    619          
    620            /* Select the External clock mode1 */
    621            TIM3->SMCR |= (uint8_t)(TIM3_SlaveMode_External1);
    622          }
    623          
    624          /**
    625            * @brief  Selects the TIM3 Input Trigger source.
    626            * @param  TIM3_InputTriggerSource : Specifies Input Trigger source.
    627            *   This parameter can be one of the @ref TIM3_TRGSelection_TypeDef enumeration.
    628            * @retval None
    629            */
    630          void TIM3_SelectInputTrigger(TIM3_TRGSelection_TypeDef TIM3_InputTriggerSource)
    631          {
    632            uint8_t tmpsmcr = 0;
    633          
    634            /* Check the parameters */
    635            assert_param(IS_TIM3_TRIGGER_SELECTION(TIM3_InputTriggerSource));
    636          
    637            tmpsmcr = TIM3->SMCR;
    638          
    639            /* Select the Tgigger Source */
    640            tmpsmcr &= (uint8_t)(~TIM_SMCR_TS);
    641            tmpsmcr |= (uint8_t)TIM3_InputTriggerSource;
    642          
    643            TIM3->SMCR = (uint8_t)tmpsmcr;
    644          }
    645          
    646          /**
    647            * @brief  Enables or Disables the TIM3 Update event.
    648            * @param NewState : The new state of the TIM3 peripheral Preload register.
    649            *   This parameter can be any of the @ref FunctionalState enumeration.
    650            * @retval None
    651            */
    652          
    653          void TIM3_UpdateDisableConfig(FunctionalState NewState)
    654          {
    655            /* Check the parameters */
    656            assert_param(IS_FUNCTIONAL_STATE(NewState));
    657          
    658            /* Set or Reset the UDIS Bit */
    659            if (NewState != DISABLE)
    660            {
    661              TIM3->CR1 |= TIM_CR1_UDIS;
    662            }
    663            else
    664            {
    665              TIM3->CR1 &= (uint8_t)(~TIM_CR1_UDIS);
    666            }
    667          }
    668          
    669          /**
    670            * @brief  Selects the TIM3 Update Request Interrupt source.
    671            * @param  TIM3_UpdateSource : Specifies the Update source.
    672            *   This parameter can be one of the @ref TIM3_UpdateSource_TypeDef enumeration.
    673            * @retval None
    674            */
    675          void TIM3_UpdateRequestConfig(TIM3_UpdateSource_TypeDef TIM3_UpdateSource)
    676          {
    677            /* Check the parameters */
    678            assert_param(IS_TIM3_UPDATE_SOURCE(TIM3_UpdateSource));
    679          
    680            /* Set or Reset the URS Bit */
    681            if (TIM3_UpdateSource == TIM3_UpdateSource_Regular)
    682            {
    683              TIM3->CR1 |= TIM_CR1_URS ;
    684            }
    685            else
    686            {
    687              TIM3->CR1 &= (uint8_t)(~TIM_CR1_URS);
    688            }
    689          }
    690          
    691          /**
    692            * @brief  Enables or Disables the TIM’s Hall sensor interface.
    693            * @param NewState : The new state of the TIM3 Hall sensor interface.
    694            *   This parameter can be any of the @ref FunctionalState enumeration.
    695            * @retval None
    696            */
    697          void TIM3_SelectHallSensor(FunctionalState NewState)
    698          {
    699            /* Check the parameters */
    700            assert_param(IS_FUNCTIONAL_STATE(NewState));
    701          
    702            /* Set or Reset the TI1S Bit */
    703            if (NewState != DISABLE)
    704            {
    705              TIM3->CR2 |= TIM_CR2_TI1S;
    706            }
    707            else
    708            {
    709              TIM3->CR2 &= (uint8_t)(~TIM_CR2_TI1S);
    710            }
    711          }
    712          
    713          /**
    714            * @brief  Selects the TIM’s One Pulse Mode.
    715            * @param  TIM3_OPMode : Specifies the OPM Mode to be used.
    716            *   This parameter can be one of the @ref TIM3_OPMode_TypeDef enumeration.
    717            * @retval None
    718            */
    719          void TIM3_SelectOnePulseMode(TIM3_OPMode_TypeDef TIM3_OPMode)
    720          {
    721            /* Check the parameters */
    722            assert_param(IS_TIM3_OPM_MODE(TIM3_OPMode));
    723          
    724            /* Set or Reset the OPM Bit */
    725            if (TIM3_OPMode == TIM3_OPMode_Single)
    726            {
    727              TIM3->CR1 |= TIM_CR1_OPM ;
    728            }
    729            else
    730            {
    731              TIM3->CR1 &= (uint8_t)(~TIM_CR1_OPM);
    732            }
    733          }
    734          
    735          /**
    736            * @brief  Selects the TIM3 Trigger Output Mode.
    737            * @param  TIM3_TRGOSource : Specifies the Trigger Output source.
    738            *   This parameter can be one of the @ref TIM3_TRGOSource_TypeDef enumeration.
    739            * @retval None
    740            */
    741          void TIM3_SelectOutputTrigger(TIM3_TRGOSource_TypeDef TIM3_TRGOSource)
    742          {
    743            uint8_t tmpcr2 = 0;
    744          
    745            /* Check the parameters */
    746            assert_param(IS_TIM3_TRGO_SOURCE(TIM3_TRGOSource));
    747          
    748            tmpcr2 = TIM3->CR2;
    749          
    750            /* Reset the MMS Bits */
    751            tmpcr2 &= (uint8_t)(~TIM_CR2_MMS);
    752          
    753            /* Select the TRGO source */
    754            tmpcr2 |=  (uint8_t)TIM3_TRGOSource;
    755          
    756            TIM3->CR2 = tmpcr2;
    757          }
    758          
    759          /**
    760            * @brief  Selects the TIM3 Slave Mode.
    761            * @param  TIM3_SlaveMode : Specifies the TIM3 Slave Mode.
    762            *   This parameter can be one of the @ref TIM3_SlaveMode_TypeDef enumeration.
    763            * @retval None
    764            */
    765          void TIM3_SelectSlaveMode(TIM3_SlaveMode_TypeDef TIM3_SlaveMode)
    766          {
    767            uint8_t tmpsmcr = 0;
    768          
    769            /* Check the parameters */
    770            assert_param(IS_TIM3_SLAVE_MODE(TIM3_SlaveMode));
    771          
    772            tmpsmcr = TIM3->SMCR;
    773          
    774            /* Reset the SMS Bits */
    775            tmpsmcr &= (uint8_t)(~TIM_SMCR_SMS);
    776          
    777            /* Select the Slave Mode */
    778            tmpsmcr |= (uint8_t)TIM3_SlaveMode;
    779          
    780            TIM3->SMCR = tmpsmcr;
    781          }
    782          
    783          /**
    784            * @brief  Sets or Resets the TIM3 Master/Slave Mode.
    785            * @param NewState : The new state of the synchronization between TIM3 and its slaves (through TRGO).
    786            *   This parameter can be any of the @ref FunctionalState enumeration.
    787            * @retval None
    788            */
    789          void TIM3_SelectMasterSlaveMode(FunctionalState NewState)
    790          {
    791            /* Check the parameters */
    792            assert_param(IS_FUNCTIONAL_STATE(NewState));
    793          
    794            /* Set or Reset the MSM Bit */
    795            if (NewState != DISABLE)
    796            {
    797              TIM3->SMCR |= TIM_SMCR_MSM;
    798            }
    799            else
    800            {
    801              TIM3->SMCR &= (uint8_t)(~TIM_SMCR_MSM);
    802            }
    803          }
    804          
    805          /**
    806            * @brief  Configures the TIM3 Encoder Interface.
    807            * @param  TIM3_EncoderMode : Specifies the TIM3 Encoder Mode.
    808            *   This parameter can be one of the @ref TIM3_EncoderMode_TypeDef enumeration.
    809            * @param  TIM3_IC1Polarity : Specifies the IC1 Polarity.
    810            *   This parameter can be one of the @ref TIM3_ICPolarity_TypeDef enumeration.
    811            * @param  TIM3_IC2Polarity : Specifies the IC2 Polarity.
    812            *   This parameter can be one of the @ref TIM3_ICPolarity_TypeDef enumeration.
    813            * @retval None
    814            */
    815          void TIM3_EncoderInterfaceConfig(TIM3_EncoderMode_TypeDef TIM3_EncoderMode,
    816                                           TIM3_ICPolarity_TypeDef TIM3_IC1Polarity,
    817                                           TIM3_ICPolarity_TypeDef TIM3_IC2Polarity)
    818          {
    819            uint8_t tmpsmcr = 0;
    820            uint8_t tmpccmr1 = 0;
    821            uint8_t tmpccmr2 = 0;
    822          
    823            /* Check the parameters */
    824            assert_param(IS_TIM3_ENCODER_MODE(TIM3_EncoderMode));
    825            assert_param(IS_TIM3_IC_POLARITY(TIM3_IC1Polarity));
    826            assert_param(IS_TIM3_IC_POLARITY(TIM3_IC2Polarity));
    827          
    828            tmpsmcr = TIM3->SMCR;
    829            tmpccmr1 = TIM3->CCMR1;
    830            tmpccmr2 = TIM3->CCMR2;
    831          
    832            /* Set the encoder Mode */
    833            tmpsmcr &= (uint8_t)(TIM_SMCR_MSM | TIM_SMCR_TS)  ;
    834            tmpsmcr |= (uint8_t)TIM3_EncoderMode;
    835          
    836            /* Select the Capture Compare 1 and the Capture Compare 2 as input */
    837            tmpccmr1 &= (uint8_t)(~TIM_CCMR_CCxS);
    838            tmpccmr2 &= (uint8_t)(~TIM_CCMR_CCxS);
    839            tmpccmr1 |= TIM_CCMR_TIxDirect_Set;
    840            tmpccmr2 |= TIM_CCMR_TIxDirect_Set;
    841          
    842            /* Set the TI1 and the TI2 Polarities */
    843            if (TIM3_IC1Polarity == TIM3_ICPolarity_Falling)
    844            {
    845              TIM3->CCER1 |= TIM_CCER1_CC1P ;
    846            }
    847            else
    848            {
    849              TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC1P) ;
    850            }
    851          
    852            if (TIM3_IC2Polarity == TIM3_ICPolarity_Falling)
    853            {
    854              TIM3->CCER1 |= TIM_CCER1_CC2P ;
    855            }
    856            else
    857            {
    858              TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC2P) ;
    859            }
    860          
    861            TIM3->SMCR = tmpsmcr;
    862            TIM3->CCMR1 = tmpccmr1;
    863            TIM3->CCMR2 = tmpccmr2;
    864          }
    865          
    866          /**
    867            * @brief  Configures the TIM3 Prescaler.
    868            * @param Prescaler : Specifies the Prescaler Register value
    869            *   This parameter can be one of the @ref TIM3_Prescaler_TypeDef enumeration.
    870            * @param  TIM3_PSCReloadMode : Specifies the TIM3 Prescaler Reload mode.
    871            *   This parameter can be one of the @ref TIM3_PSCReloadMode_TypeDef enumeration.
    872            * @retval None
    873            */
    874          void TIM3_PrescalerConfig(TIM3_Prescaler_TypeDef Prescaler,
    875                                    TIM3_PSCReloadMode_TypeDef TIM3_PSCReloadMode)
    876          {
    877            /* Check the parameters */
    878            assert_param(IS_TIM3_PRESCALER(Prescaler));
    879            assert_param(IS_TIM3_PRESCALER_RELOAD(TIM3_PSCReloadMode));
    880          
    881            /* Set the Prescaler value */
    882            TIM3->PSCR = (uint8_t)(Prescaler);
    883          
    884            /* Set or reset the UG Bit */
    885            if (TIM3_PSCReloadMode == TIM3_PSCReloadMode_Immediate)
    886            {
    887              TIM3->EGR |= TIM_EGR_UG ;
    888            }
    889            else
    890            {
    891              TIM3->EGR &= (uint8_t)(~TIM_EGR_UG) ;
    892            }
    893          }
    894          
    895          /**
    896            * @brief  Specifies the TIM3 Counter Mode to be used.
    897            * @param  TIM3_CounterMode : Specifies the Counter Mode to be used
    898            *   This parameter can be one of the @ref TIM3_CounterMode_TypeDef enumeration.
    899            * @retval None
    900            */
    901          void TIM3_CounterModeConfig(TIM3_CounterMode_TypeDef TIM3_CounterMode)
    902          {
    903            uint8_t tmpcr1 = 0;
    904          
    905            /* Check the parameters */
    906            assert_param(IS_TIM3_COUNTER_MODE(TIM3_CounterMode));
    907          
    908            tmpcr1 = TIM3->CR1;
    909          
    910            /* Reset the CMS and DIR Bits */
    911            tmpcr1 &= (uint8_t)((uint8_t)(~TIM_CR1_CMS) & (uint8_t)(~TIM_CR1_DIR));
    912          
    913            /* Set the Counter Mode */
    914            tmpcr1 |= (uint8_t)TIM3_CounterMode;
    915          
    916            TIM3->CR1 = tmpcr1;
    917          }
    918          
    919          /**
    920            * @brief  Forces the TIM3 Channel1 output waveform to active or inactive level.
    921            * @param  TIM3_ForcedAction : Specifies the forced Action to be set to the output waveform.
    922            *   This parameter can be one of the @ref TIM3_ForcedAction_TypeDef enumeration.
    923            * @retval None
    924            */
    925          void TIM3_ForcedOC1Config(TIM3_ForcedAction_TypeDef TIM3_ForcedAction)
    926          {
    927            uint8_t tmpccmr1 = 0;
    928          
    929            /* Check the parameters */
    930            assert_param(IS_TIM3_FORCED_ACTION(TIM3_ForcedAction));
    931          
    932            tmpccmr1 = TIM3->CCMR1;
    933          
    934            /* Reset the OCM Bits */
    935            tmpccmr1 &= (uint8_t)(~TIM_CCMR_OCM);
    936          
    937            /* Configure The Forced output Mode */
    938            tmpccmr1 |= (uint8_t)TIM3_ForcedAction;
    939          
    940            TIM3->CCMR1 = tmpccmr1;
    941          }
    942          
    943          /**
    944            * @brief  Forces the TIM3 Channel2 output waveform to active or inactive level.
    945            * @param  TIM3_ForcedAction : Specifies the forced Action to be set to the output waveform.
    946            *   This parameter can be one of the @ref TIM3_ForcedAction_TypeDef enumeration.
    947            * @retval None
    948            */
    949          void TIM3_ForcedOC2Config(TIM3_ForcedAction_TypeDef TIM3_ForcedAction)
    950          {
    951            uint8_t tmpccmr2 = 0;
    952          
    953            /* Check the parameters */
    954            assert_param(IS_TIM3_FORCED_ACTION(TIM3_ForcedAction));
    955          
    956            tmpccmr2 = TIM3->CCMR2;
    957          
    958            /* Reset the OCM Bits */
    959            tmpccmr2 &= (uint8_t)(~TIM_CCMR_OCM);
    960          
    961            /* Configure The Forced output Mode */
    962            tmpccmr2 |= (uint8_t)TIM3_ForcedAction;
    963          
    964            TIM3->CCMR2 = tmpccmr2;
    965          }
    966          
    967          /**
    968            * @brief  Enables or disables TIM3 peripheral Preload register on ARR.
    969            * @param NewState : The new state of the TIM3 peripheral Preload register.
    970            *   This parameter can be any of the @ref FunctionalState enumeration.
    971            * @retval None
    972            */
    973          void TIM3_ARRPreloadConfig(FunctionalState NewState)
    974          {
    975            /* Check the parameters */
    976            assert_param(IS_FUNCTIONAL_STATE(NewState));
    977          
    978            /* Set or Reset the ARPE Bit */
    979            if (NewState != DISABLE)
    980            {
    981              TIM3->CR1 |= TIM_CR1_ARPE;
    982            }
    983            else
    984            {
    985              TIM3->CR1 &= (uint8_t)(~TIM_CR1_ARPE);
    986            }
    987          }
    988          
    989          /**
    990            * @brief  Enables or disables the TIM3 peripheral Preload Register on CCR1.
    991            * @param NewState : new state of the Capture Compare Preload register.
    992            *   This parameter can be any of the @ref FunctionalState enumeration.
    993            * @retval None
    994            */
    995          void TIM3_OC1PreloadConfig(FunctionalState NewState)
    996          {
    997            /* Check the parameters */
    998            assert_param(IS_FUNCTIONAL_STATE(NewState));
    999          
   1000            /* Set or Reset the OC1PE Bit */
   1001            if (NewState != DISABLE)
   1002            {
   1003              TIM3->CCMR1 |= TIM_CCMR_OCxPE ;
   1004            }
   1005            else
   1006            {
   1007              TIM3->CCMR1 &= (uint8_t)(~TIM_CCMR_OCxPE) ;
   1008            }
   1009          }
   1010          
   1011          /**
   1012            * @brief  Enables or disables the TIM3 peripheral Preload Register on CCR2.
   1013            * @param NewState : The new state of the Capture Compare Preload register.
   1014            *   This parameter can be any of the @ref FunctionalState enumeration.
   1015            * @retval None
   1016            */
   1017          void TIM3_OC2PreloadConfig(FunctionalState NewState)
   1018          {
   1019            /* Check the parameters */
   1020            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1021          
   1022            /* Set or Reset the OC2PE Bit */
   1023            if (NewState != DISABLE)
   1024            {
   1025              TIM3->CCMR2 |= TIM_CCMR_OCxPE ;
   1026            }
   1027            else
   1028            {
   1029              TIM3->CCMR2 &= (uint8_t)(~TIM_CCMR_OCxPE) ;
   1030            }
   1031          }
   1032          
   1033          /**
   1034            * @brief  Configures the TIM3 Capture Compare 1 Fast feature.
   1035            * @param NewState : The new state of the Output Compare Fast Enable bit.
   1036            *   This parameter can be any of the @ref FunctionalState enumeration.
   1037            * @retval None
   1038            */
   1039          void TIM3_OC1FastCmd(FunctionalState NewState)
   1040          {
   1041            /* Check the parameters */
   1042            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1043          
   1044            /* Set or Reset the OC1FE Bit */
   1045            if (NewState != DISABLE)
   1046            {
   1047              TIM3->CCMR1 |= TIM_CCMR_OCxFE ;
   1048            }
   1049            else
   1050            {
   1051              TIM3->CCMR1 &= (uint8_t)(~TIM_CCMR_OCxFE) ;
   1052            }
   1053          }
   1054          
   1055          /**
   1056            * @brief  Configures the TIM3 Capture Compare 2 Fast feature.
   1057            * @param NewState : The new state of the Output Compare Fast Enable bit.
   1058            *   This parameter can be any of the @ref FunctionalState enumeration.
   1059            * @retval None
   1060            */
   1061          
   1062          void TIM3_OC2FastCmd(FunctionalState NewState)
   1063          {
   1064            /* Check the parameters */
   1065            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1066          
   1067            /* Set or Reset the OC2FE Bit */
   1068            if (NewState != DISABLE)
   1069            {
   1070              TIM3->CCMR2 |= TIM_CCMR_OCxFE ;
   1071            }
   1072            else
   1073            {
   1074              TIM3->CCMR2 &= (uint8_t)(~TIM_CCMR_OCxFE) ;
   1075            }
   1076          }
   1077          
   1078          /**
   1079            * @brief  Configures the TIM3 event to be generated by software.
   1080            * @param  TIM3_EventSource : Specifies the event source.
   1081            *   This parameter can be one of the @ref TIM3_EventSource_TypeDef enumeration.
   1082            * @retval None
   1083            */
   1084          void TIM3_GenerateEvent(TIM3_EventSource_TypeDef TIM3_EventSource)
   1085          {
   1086            /* Check the parameters */
   1087            assert_param(IS_TIM3_EVENT_SOURCE((uint8_t)TIM3_EventSource));
   1088          
   1089            /* Set the event sources */
   1090            TIM3->EGR |= (uint8_t)TIM3_EventSource;
   1091          }
   1092          
   1093          /**
   1094            * @brief  Configures the TIM3 Channel 1 polarity.
   1095            * @param  TIM3_OCPolarity : Specifies the OC1 Polarity.
   1096            *   This parameter can be one of the @ref TIM3_OCPolarity_TypeDef enumeration.
   1097            * @retval None
   1098            */
   1099          void TIM3_OC1PolarityConfig(TIM3_OCPolarity_TypeDef TIM3_OCPolarity)
   1100          {
   1101            /* Check the parameters */
   1102            assert_param(IS_TIM3_OC_POLARITY(TIM3_OCPolarity));
   1103          
   1104            /* Set or Reset the CC1P Bit */
   1105            if (TIM3_OCPolarity == TIM3_OCPolarity_Low)
   1106            {
   1107              TIM3->CCER1 |= TIM_CCER1_CC1P ;
   1108            }
   1109            else
   1110            {
   1111              TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC1P) ;
   1112            }
   1113          }
   1114          
   1115          /**
   1116            * @brief  Configures the TIM3 Channel 2 polarity.
   1117            * @param  TIM3_OCPolarity : Specifies the OC2 Polarity.
   1118            *   This parameter can be one of the @ref TIM3_OCPolarity_TypeDef enumeration.
   1119            * @retval None
   1120            */
   1121          void TIM3_OC2PolarityConfig(TIM3_OCPolarity_TypeDef TIM3_OCPolarity)
   1122          {
   1123            /* Check the parameters */
   1124            assert_param(IS_TIM3_OC_POLARITY(TIM3_OCPolarity));
   1125          
   1126            /* Set or Reset the CC2P Bit */
   1127            if (TIM3_OCPolarity == TIM3_OCPolarity_Low)
   1128            {
   1129              TIM3->CCER1 |= TIM_CCER1_CC2P ;
   1130            }
   1131            else
   1132            {
   1133              TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC2P) ;
   1134            }
   1135          }
   1136          
   1137          /**
   1138            * @brief  Enables or disables the TIM3 Capture Compare Channel x.
   1139            * @param  TIM3_Channel : Specifies the TIM3 Channel.
   1140            *   This parameter can be one of @ref TIM3_Channel_TypeDef enumeration.
   1141            * @param NewState : specifies the TIM3 Channel CCxE bit new state.
   1142            *   This parameter can be any of the @ref FunctionalState enumeration.
   1143            * @retval None
   1144            */
   1145          void TIM3_CCxCmd(TIM3_Channel_TypeDef TIM3_Channel, FunctionalState NewState)
   1146          {
   1147            /* Check the parameters */
   1148            assert_param(IS_TIM3_CHANNEL(TIM3_Channel));
   1149            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1150          
   1151            if (TIM3_Channel == TIM3_Channel_1)
   1152            {
   1153              /* Set or Reset the CC1E Bit */
   1154              if (NewState != DISABLE)
   1155              {
   1156                TIM3->CCER1 |= TIM_CCER1_CC1E ;
   1157              }
   1158              else
   1159              {
   1160                TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC1E) ;
   1161              }
   1162          
   1163            }
   1164            else /* if (TIM3_Channel == TIM3_Channel_2) */
   1165            {
   1166              /* Set or Reset the CC2E Bit */
   1167              if (NewState != DISABLE)
   1168              {
   1169                TIM3->CCER1 |= TIM_CCER1_CC2E;
   1170              }
   1171              else
   1172              {
   1173                TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC2E) ;
   1174              }
   1175            }
   1176          }
   1177          
   1178          /**
   1179            * @brief  Selects the TIM3 Ouput Compare Mode. This function disables the
   1180            * selected channel before changing the Ouput Compare Mode. User has to
   1181            * enable this channel using TIM3_CCxCmd and TIM3_CCxNCmd functions.
   1182            * @param  TIM3_Channel : Specifies the TIM3 Channel.
   1183            *   This parameter can be one of the @ref TIM3_Channel_TypeDef enumeration
   1184            * @param  TIM3_OCMode : Specifies the TIM3 Output Compare Mode.
   1185            * This paramter can be one of the @ref TIM3_OCMode_TypeDef enumeration.
   1186            * @retval None
   1187            */
   1188          void TIM3_SelectOCxM(TIM3_Channel_TypeDef TIM3_Channel,
   1189                               TIM3_OCMode_TypeDef TIM3_OCMode)
   1190          {
   1191            /* Check the parameters */
   1192            assert_param(IS_TIM3_CHANNEL(TIM3_Channel));
   1193            assert_param(IS_TIM3_OCM(TIM3_OCMode));
   1194          
   1195            if (TIM3_Channel == TIM3_Channel_1)
   1196            {
   1197              /* Disable the Channel 1: Reset the CCE Bit */
   1198              TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC1E);
   1199          
   1200              /* Reset the Output Compare Bits */
   1201              TIM3->CCMR1 &= (uint8_t)(~TIM_CCMR_OCM);
   1202          
   1203              /* Set the Ouput Compare Mode */
   1204              TIM3->CCMR1 |= (uint8_t)TIM3_OCMode;
   1205            }
   1206            else /* if (TIM3_Channel == TIM3_Channel_2) */
   1207            {
   1208              /* Disable the Channel 2: Reset the CCE Bit */
   1209              TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC2E);
   1210          
   1211              /* Reset the Output Compare Bits */
   1212              TIM3->CCMR2 &= (uint8_t)(~TIM_CCMR_OCM);
   1213          
   1214              /* Set the Ouput Compare Mode */
   1215              TIM3->CCMR2 |= (uint8_t)TIM3_OCMode;
   1216            }
   1217          }
   1218          
   1219          /**
   1220            * @brief  Sets the TIM3 Counter Register value.
   1221            * @param  Counter : Specifies the Counter register new value.
   1222            *   This parameter is between 0x0000 and 0xFFFF.
   1223            * @retval None
   1224            */
   1225          void TIM3_SetCounter(uint16_t Counter)
   1226          {
   1227            /* Set the Counter Register value */
   1228            TIM3->CNTRH = (uint8_t)(Counter >> 8);
   1229            TIM3->CNTRL = (uint8_t)(Counter);
   1230          }
   1231          
   1232          /**
   1233            * @brief  Sets the TIM3 Autoreload Register value.
   1234            * @param  Autoreload : Specifies the Autoreload register new value.
   1235            *   This parameter is between 0x0000 and 0xFFFF.
   1236            * @retval None
   1237            */
   1238          void TIM3_SetAutoreload(uint16_t Autoreload)
   1239          {
   1240            /* Set the Autoreload Register value */
   1241            TIM3->ARRH = (uint8_t)(Autoreload >> 8);
   1242            TIM3->ARRL = (uint8_t)(Autoreload);
   1243          }
   1244          
   1245          /**
   1246            * @brief  Sets the TIM3 Capture Compare1 Register value.
   1247            * @param  Compare : Specifies the Capture Compare1 register new value.
   1248            *   This parameter is between 0x0000 and 0xFFFF.
   1249            * @retval None
   1250            */
   1251          void TIM3_SetCompare1(uint16_t Compare)
   1252          {
   1253            /* Set the Capture Compare1 Register value */
   1254            TIM3->CCR1H = (uint8_t)(Compare >> 8);
   1255            TIM3->CCR1L = (uint8_t)(Compare);
   1256          }
   1257          
   1258          /**
   1259            * @brief  Sets the TIM3 Capture Compare2 Register value.
   1260            * @param  Compare : Specifies the Capture Compare2 register new value.
   1261            *   This parameter is between 0x0000 and 0xFFFF.
   1262            * @retval None
   1263            */
   1264          void TIM3_SetCompare2(uint16_t Compare)
   1265          {
   1266            /* Set the Capture Compare2 Register value */
   1267            TIM3->CCR2H = (uint8_t)(Compare >> 8);
   1268            TIM3->CCR2L = (uint8_t)(Compare);
   1269          }
   1270          
   1271          /**
   1272            * @brief  Sets the TIM3 Input Capture 1 prescaler.
   1273            * @param  TIM3_IC1Prescaler : Specifies the Input Capture prescaler new value
   1274            *   This parameter can be one of the @ref TIM3_ICPSC_TypeDef enumeration.
   1275            * @retval None
   1276            */
   1277          void TIM3_SetIC1Prescaler(TIM3_ICPSC_TypeDef TIM3_IC1Prescaler)
   1278          {
   1279            uint8_t tmpccmr1 = 0;
   1280          
   1281            /* Check the parameters */
   1282            assert_param(IS_TIM3_IC_PRESCALER(TIM3_IC1Prescaler));
   1283          
   1284            tmpccmr1 = TIM3->CCMR1;
   1285          
   1286            /* Reset the IC1PSC Bits */
   1287            tmpccmr1 &= (uint8_t)(~TIM_CCMR_ICxPSC);
   1288          
   1289            /* Set the IC1PSC value */
   1290            tmpccmr1 |= (uint8_t)TIM3_IC1Prescaler;
   1291          
   1292            TIM3->CCMR1 = tmpccmr1;
   1293          }
   1294          
   1295          /**
   1296            * @brief  Sets the TIM3 Input Capture 2 prescaler.
   1297            * @param  TIM3_IC2Prescaler : Specifies the Input Capture prescaler new value
   1298            *   This parameter can be one of the @ref TIM3_ICPSC_TypeDef enumeration.
   1299            * @retval None
   1300            */
   1301          void TIM3_SetIC2Prescaler(TIM3_ICPSC_TypeDef TIM3_IC2Prescaler)
   1302          {
   1303            uint8_t tmpccmr2 = 0;
   1304          
   1305            /* Check the parameters */
   1306            assert_param(IS_TIM3_IC_PRESCALER(TIM3_IC2Prescaler));
   1307          
   1308            tmpccmr2 = TIM3->CCMR2;
   1309          
   1310            /* Reset the IC2PSC Bits */
   1311            tmpccmr2 &= (uint8_t)(~TIM_CCMR_ICxPSC);
   1312          
   1313            /* Set the IC2PSC value */
   1314            tmpccmr2 |= (uint8_t)TIM3_IC2Prescaler;
   1315          
   1316            TIM3->CCMR2 = tmpccmr2;
   1317          }
   1318          
   1319          /**
   1320            * @brief  Gets the TIM3 Input Capture 1 value.
   1321            * @param  None
   1322            * @retval Capture Compare 1 Register value.
   1323            */
   1324          uint16_t TIM3_GetCapture1(void)
   1325          {
   1326            uint16_t tmpccr1 = 0;
   1327            uint8_t tmpccr1l, tmpccr1h;
   1328          
   1329            tmpccr1h = TIM3->CCR1H;
   1330            tmpccr1l = TIM3->CCR1L;
   1331          
   1332            tmpccr1 = (uint16_t)(tmpccr1l);
   1333            tmpccr1 |= (uint16_t)((uint16_t)tmpccr1h << 8);
   1334            /* Get the Capture 1 Register value */
   1335            return ((uint16_t)tmpccr1);
   1336          }
   1337          
   1338          /**
   1339            * @brief  Gets the TIM3 Input Capture 2 value.
   1340            * @param  None
   1341            * @retval Capture Compare 2 Register value.
   1342            */
   1343          uint16_t TIM3_GetCapture2(void)
   1344          {
   1345            uint16_t tmpccr2 = 0;
   1346            uint8_t tmpccr2l, tmpccr2h;
   1347          
   1348            tmpccr2h = TIM3->CCR2H;
   1349            tmpccr2l = TIM3->CCR2L;
   1350          
   1351            tmpccr2 = (uint16_t)(tmpccr2l);
   1352            tmpccr2 |= (uint16_t)((uint16_t)tmpccr2h << 8);
   1353            /* Get the Capture 2 Register value */
   1354            return ((uint16_t)tmpccr2);
   1355          }
   1356          
   1357          /**
   1358            * @brief  Gets the TIM3 Counter value.
   1359            * @param  None
   1360            * @retval Counter Register value.
   1361            */
   1362          uint16_t TIM3_GetCounter(void)
   1363          {
   1364            uint16_t tmpcnt = 0;
   1365            uint8_t tmpcntrl, tmpcntrh;
   1366          
   1367            tmpcntrh = TIM3->CNTRH;
   1368            tmpcntrl = TIM3->CNTRL;
   1369          
   1370            tmpcnt = (uint16_t)(tmpcntrl);
   1371            tmpcnt |= (uint16_t)((uint16_t)tmpcntrh << 8);
   1372            /* Get the Counter Register value */
   1373            return ((uint16_t)tmpcnt);
   1374          }
   1375          
   1376          /**
   1377            * @brief  Gets the TIM3 Prescaler value.
   1378            * @param  None
   1379            * @retval TIM3_Prescaler_TypeDef : Prescaler Register value.
   1380            */
   1381          TIM3_Prescaler_TypeDef TIM3_GetPrescaler(void)
   1382          {
   1383            /* Get the Prescaler Register value */
   1384            return ((TIM3_Prescaler_TypeDef)TIM3->PSCR);
   1385          }
   1386          
   1387          /**
   1388            * @brief  Selects the TIM3 peripheral Capture Compare DMA source.
   1389            * @param  NewState: new state of the Capture Compare DMA source.
   1390            *   This parameter can be: ENABLE or DISABLE.
   1391            * @retval None
   1392            */
   1393          void TIM3_SelectCCDMA(FunctionalState NewState)
   1394          {
   1395            /* Check the parameters */
   1396            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1397          
   1398            if (NewState != DISABLE)
   1399            {
   1400              /* Set the CCDS Bit */
   1401              TIM3->CR2 |= TIM_CR2_CCDS;
   1402            }
   1403            else
   1404            {
   1405              /* Reset the CCDS Bit */
   1406              TIM3->CR2 &= (uint8_t)(~TIM_CR2_CCDS);
   1407            }
   1408          }
   1409          
   1410          /**
   1411            * @brief  Checks whether the specified TIM3 flag is set or not.
   1412            * @param  TIM3_FLAG : Specifies the flag to check.
   1413            *   This parameter can be one of the @ref TIM3_FLAG_TypeDef enumeration.
   1414            * @retval FlagStatus : The new state of TIM3_FLAG.
   1415            *   This parameter can be any of the @ref FlagStatus enumeration.
   1416            */
   1417          FlagStatus TIM3_GetFlagStatus(TIM3_FLAG_TypeDef TIM3_FLAG)
   1418          {
   1419            FlagStatus bitstatus = RESET;
   1420            uint8_t tim3_flag_l = 0, tim3_flag_h = 0;
   1421          
   1422            /* Check the parameters */
   1423            assert_param(IS_TIM3_GET_FLAG(TIM3_FLAG));
   1424          
   1425            tim3_flag_l = (uint8_t)(TIM3->SR1 & (uint8_t)(TIM3_FLAG));
   1426            tim3_flag_h = (uint8_t)(TIM3->SR2 & (uint8_t)((uint16_t)TIM3_FLAG >> 8));
   1427          
   1428            if ((uint8_t)(tim3_flag_l | tim3_flag_h) != 0)
   1429            {
   1430              bitstatus = SET;
   1431            }
   1432            else
   1433            {
   1434              bitstatus = RESET;
   1435            }
   1436            return ((FlagStatus)bitstatus);
   1437          }
   1438          
   1439          /**
   1440            * @brief  Clears the TIM’s pending flags.
   1441            * @param  TIM3_FLAG : Specifies the flag to clear.
   1442            *   This parameter can be one of the @ref TIM3_FLAG_TypeDef enumeration.
   1443            * @retval None
   1444            */
   1445          void TIM3_ClearFlag(TIM3_FLAG_TypeDef TIM3_FLAG)
   1446          {
   1447            /* Check the parameters */
   1448            assert_param(IS_TIM3_CLEAR_FLAG((uint16_t)TIM3_FLAG));
   1449            /* Clear the flags (rc_w0) clear this bit by writing 0. Writing ‘1’ has no effect*/
   1450            TIM3->SR1 = (uint8_t)(~(uint8_t)(TIM3_FLAG));
   1451            TIM3->SR2 = (uint8_t)(~(uint8_t)((uint16_t)TIM3_FLAG >> 8));
   1452          }
   1453          
   1454          /**
   1455            * @brief  Checks whether the TIM3 interrupt has occurred or not.
   1456            * @param  TIM3_IT : Specifies the TIM3 interrupt source to check.
   1457            *   This parameter can be one of the @ref TIM3_IT_TypeDef enumeration.
   1458            * @retval ITStatus : The new state of the TIM3_IT.
   1459            *   This parameter can be any of the @ref ITStatus enumeration.
   1460            */
   1461          
   1462          ITStatus TIM3_GetITStatus(TIM3_IT_TypeDef TIM3_IT)
   1463          {
   1464            ITStatus bitstatus = RESET;
   1465          
   1466            uint8_t TIM3_itStatus = 0x0, TIM3_itEnable = 0x0;
   1467          
   1468            /* Check the parameters */
   1469            assert_param(IS_TIM3_GET_IT(TIM3_IT));
   1470          
   1471            TIM3_itStatus = (uint8_t)(TIM3->SR1 & (uint8_t)TIM3_IT);
   1472          
   1473            TIM3_itEnable = (uint8_t)(TIM3->IER & (uint8_t)TIM3_IT);
   1474          
   1475            if ((TIM3_itStatus != (uint8_t)RESET) && (TIM3_itEnable != (uint8_t)RESET))
   1476            {
   1477              bitstatus = (ITStatus)SET;
   1478            }
   1479            else
   1480            {
   1481              bitstatus = (ITStatus)RESET;
   1482            }
   1483            return ((ITStatus)bitstatus);
   1484          }
   1485          
   1486          /**
   1487            * @brief  Clears the TIM's interrupt pending bits.
   1488            * @param  TIM3_IT : Specifies the pending bit to clear.
   1489            *   This parameter can be one of the @ref TIM3_IT_TypeDef enumeration.
   1490            * @retval None
   1491            */
   1492          void TIM3_ClearITPendingBit(TIM3_IT_TypeDef TIM3_IT)
   1493          {
   1494            /* Check the parameters */
   1495            assert_param(IS_TIM3_IT(TIM3_IT));
   1496          
   1497            /* Clear the IT pending Bit */
   1498            TIM3->SR1 = (uint8_t)(~(uint8_t)TIM3_IT);
   1499          }
   1500          
   1501          /**
   1502            * @brief  Configure the TI1 as Input.
   1503            * @param  TIM3_ICPolarity : The Input Polarity.
   1504            *   This parameter can be one of the @ref TIM3_ICPolarity_TypeDef enumeration.
   1505            * @param  TIM3_ICSelection : Specifies the input to be used.
   1506            *   This parameter can be one of the @ref TIM3_ICSelection_TypeDef enumeration.
   1507            * @param  TIM3_ICFilter : Specifies the Input Capture Filter.
   1508            *   This parameter must be a value between 0x00 and 0x0F.
   1509            * @retval None
   1510            */
   1511          static void TI1_Config(TIM3_ICPolarity_TypeDef TIM3_ICPolarity,
   1512                                 TIM3_ICSelection_TypeDef TIM3_ICSelection,
   1513                                 uint8_t TIM3_ICFilter)
   1514          {
   1515            uint8_t tmpccmr1 = 0;
   1516            uint8_t tmpicpolarity = TIM3_ICPolarity;
   1517            tmpccmr1 = TIM3->CCMR1;
   1518          
   1519            /* Check the parameters */
   1520            assert_param(IS_TIM3_IC_POLARITY(TIM3_ICPolarity));
   1521            assert_param(IS_TIM3_IC_SELECTION(TIM3_ICSelection));
   1522            assert_param(IS_TIM3_IC_FILTER(TIM3_ICFilter));
   1523          
   1524            /* Disable the Channel 1: Reset the CCE Bit */
   1525            TIM3->CCER1 &=  (uint8_t)(~TIM_CCER1_CC1E);
   1526          
   1527            /* Select the Input and set the filter */
   1528            tmpccmr1 &= (uint8_t)(~TIM_CCMR_CCxS) & (uint8_t)(~TIM_CCMR_ICxF);
   1529            tmpccmr1 |= (uint8_t)(((uint8_t)(TIM3_ICSelection)) | ((uint8_t)(TIM3_ICFilter << 4)));
   1530          
   1531            TIM3->CCMR1 = tmpccmr1;
   1532          
   1533            /* Select the Polarity */
   1534            if (tmpicpolarity == (uint8_t)(TIM3_ICPolarity_Falling))
   1535            {
   1536              TIM3->CCER1 |= TIM_CCER1_CC1P;
   1537            }
   1538            else
   1539            {
   1540              TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC1P);
   1541            }
   1542          
   1543            /* Set the CCE Bit */
   1544            TIM3->CCER1 |=  TIM_CCER1_CC1E;
   1545          }
   1546          
   1547          /**
   1548            * @brief  Configure the TI2 as Input.
   1549            * @param  TIM3_ICPolarity : The Input Polarity.
   1550            *   This parameter can be one of the @ref TIM3_ICPolarity_TypeDef enumeration.
   1551            * @param  TIM3_ICSelection : Specifies the input to be used.
   1552            *   This parameter can be one of the @ref TIM3_ICSelection_TypeDef enumeration.
   1553            * @param  TIM3_ICFilter : Specifies the Input Capture Filter.
   1554            *   This parameter must be a value between 0x00 and 0x0F.
   1555            * @retval None
   1556            */
   1557          static void TI2_Config(TIM3_ICPolarity_TypeDef TIM3_ICPolarity,
   1558                                 TIM3_ICSelection_TypeDef TIM3_ICSelection,
   1559                                 uint8_t TIM3_ICFilter)
   1560          {
   1561            uint8_t tmpccmr2 = 0;
   1562            uint8_t tmpicpolarity = TIM3_ICPolarity;
   1563          
   1564            /* Check the parameters */
   1565            assert_param(IS_TIM3_IC_POLARITY(TIM3_ICPolarity));
   1566            assert_param(IS_TIM3_IC_SELECTION(TIM3_ICSelection));
   1567            assert_param(IS_TIM3_IC_FILTER(TIM3_ICFilter));
   1568          
   1569            tmpccmr2 = TIM3->CCMR2;
   1570          
   1571            /* Disable the Channel 2: Reset the CCE Bit */
   1572            TIM3->CCER1 &=  (uint8_t)(~TIM_CCER1_CC2E);
   1573          
   1574            /* Select the Input and set the filter */
   1575            tmpccmr2 &= (uint8_t)(~TIM_CCMR_CCxS) & (uint8_t)(~TIM_CCMR_ICxF);
   1576            tmpccmr2 |= (uint8_t)(((uint8_t)(TIM3_ICSelection)) | ((uint8_t)(TIM3_ICFilter << 4)));
   1577          
   1578            TIM3->CCMR2 = tmpccmr2;
   1579          
   1580            /* Select the Polarity */
   1581            if (tmpicpolarity == TIM3_ICPolarity_Falling)
   1582            {
   1583              TIM3->CCER1 |= TIM_CCER1_CC2P ;
   1584            }
   1585            else
   1586            {
   1587              TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC2P) ;
   1588            }
   1589          
   1590            /* Set the CCE Bit */
   1591            TIM3->CCER1 |=  TIM_CCER1_CC2E;
   1592          }
   1593          
   1594          
   1595          /**
   1596            * @}
   1597            */
   1598          
   1599          /**
   1600            * @}
   1601            */
   1602          
   1603          /******************* (C) COPYRIGHT 2010 STMicroelectronics *****END OF FILE****/

   Section sizes:

   Bytes  Function/Label
   -----  --------------
      56  TI1_Config
      56  TI2_Config
      13  TIM3_ARRPreloadConfig
      22  TIM3_BKRConfig
      31  TIM3_CCxCmd
      13  TIM3_ClearFlag
       5  TIM3_ClearITPendingBit
      13  TIM3_Cmd
      27  TIM3_CounterModeConfig
      13  TIM3_CtrlPWMOutputs
      19  TIM3_DMACmd
     101  TIM3_DeInit
      37  TIM3_ETRClockMode1Config
       9  TIM3_ETRClockMode2Config
      15  TIM3_ETRConfig
     107  TIM3_EncoderInterfaceConfig
      27  TIM3_ForcedOC1Config
      27  TIM3_ForcedOC2Config
       7  TIM3_GenerateEvent
      34  TIM3_GetCapture1
      34  TIM3_GetCapture2
      34  TIM3_GetCounter
      39  TIM3_GetFlagStatus
      41  TIM3_GetITStatus
       4  TIM3_GetPrescaler
      39  TIM3_ICInit
      19  TIM3_ITConfig
       9  TIM3_InternalClockConfig
      13  TIM3_OC1FastCmd
      93  TIM3_OC1Init
      14  TIM3_OC1PolarityConfig
      13  TIM3_OC1PreloadConfig
      13  TIM3_OC2FastCmd
      93  TIM3_OC2Init
      14  TIM3_OC2PolarityConfig
      13  TIM3_OC2PreloadConfig
     131  TIM3_PWMIConfig
      19  TIM3_PrescalerConfig
      13  TIM3_SelectCCDMA
      13  TIM3_SelectHallSensor
      27  TIM3_SelectInputTrigger
      13  TIM3_SelectMasterSlaveMode
      45  TIM3_SelectOCxM
      14  TIM3_SelectOnePulseMode
      27  TIM3_SelectOutputTrigger
      27  TIM3_SelectSlaveMode
      15  TIM3_SetAutoreload
      15  TIM3_SetCompare1
      15  TIM3_SetCompare2
      15  TIM3_SetCounter
      27  TIM3_SetIC1Prescaler
      27  TIM3_SetIC2Prescaler
      48  TIM3_TIxExternalClockConfig
      42  TIM3_TimeBaseInit
      13  TIM3_UpdateDisableConfig
      14  TIM3_UpdateRequestConfig

 
 1 677 bytes in section .far_func.text
 
 1 677 bytes of CODE memory

Errors: none
Warnings: none
