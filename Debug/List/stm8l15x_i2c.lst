###############################################################################
#
# IAR C/C++ Compiler V2.10.4.157 for STM8                 18/Jan/2017  11:34:51
# Copyright 2010-2015 IAR Systems AB.
#
#    Source file  =  
#        C:\Users\Growl\Desktop\Can_New_TB\STM8L151K4T6_Oil_Can_Drone -
#        IWDG\STM8L15x_StdPeriph_Driver\src\stm8l15x_i2c.c
#    Command line =  
#        "C:\Users\Growl\Desktop\Can_New_TB\STM8L151K4T6_Oil_Can_Drone -
#        IWDG\STM8L15x_StdPeriph_Driver\src\stm8l15x_i2c.c" -e -Ol --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_cross_call
#        --debug --code_model medium --data_model medium -o
#        "C:\Users\Growl\Desktop\Can_New_TB\STM8L151K4T6_Oil_Can_Drone -
#        IWDG\Debug\Obj\" --dlib_config "E:\My
#        Program\IAR_STM8-7.0\stm8\LIB\dlstm8mmf.h" -D STM8L15X_MD -lcN
#        "C:\Users\Growl\Desktop\Can_New_TB\STM8L151K4T6_Oil_Can_Drone -
#        IWDG\Debug\List\" -I
#        "C:\Users\Growl\Desktop\Can_New_TB\STM8L151K4T6_Oil_Can_Drone - IWDG\"
#        -I "C:\Users\Growl\Desktop\Can_New_TB\STM8L151K4T6_Oil_Can_Drone -
#        IWDG\STM8L15x_StdPeriph_Driver\inc\" -I
#        "C:\Users\Growl\Desktop\Can_New_TB\STM8L151K4T6_Oil_Can_Drone -
#        IWDG\APP\" -I
#        "C:\Users\Growl\Desktop\Can_New_TB\STM8L151K4T6_Oil_Can_Drone -
#        IWDG\BSP\" --vregs 16
#    List file    =  
#        C:\Users\Growl\Desktop\Can_New_TB\STM8L151K4T6_Oil_Can_Drone -
#        IWDG\Debug\List\stm8l15x_i2c.lst
#    Object file  =  
#        C:\Users\Growl\Desktop\Can_New_TB\STM8L151K4T6_Oil_Can_Drone -
#        IWDG\Debug\Obj\stm8l15x_i2c.o
#
###############################################################################

C:\Users\Growl\Desktop\Can_New_TB\STM8L151K4T6_Oil_Can_Drone - IWDG\STM8L15x_StdPeriph_Driver\src\stm8l15x_i2c.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm8l15x_i2c.c
      4            * @author  MCD Application Team
      5            * @version V1.4.0
      6            * @date    09/24/2010
      7            * @brief   This file provides all the I2C firmware functions.
      8            ******************************************************************************
      9            * @copy
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2010 STMicroelectronics</center></h2>
     19            */
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "stm8l15x_i2c.h"
     23          #include "stm8l15x_clk.h"
     24          
     25          /** @addtogroup STM8L15x_StdPeriph_Driver
     26            * @{
     27            */
     28          /** @defgroup I2C
     29            * @brief I2C driver modules
     30            * @{
     31            */
     32          
     33          /** @defgroup I2C_Private_TypesDefinitions
     34            * @{
     35            */
     36          
     37          /**
     38            * @}
     39            */
     40          
     41          /** @defgroup I2C_Private_Defines
     42            * @{
     43            */
     44          /* I2C register mask */
     45          #define REGISTER_Mask               ((uint16_t)0x3000)
     46          #define REGISTER_SR1_Index          ((uint16_t)0x0100)
     47          #define REGISTER_SR2_Index          ((uint16_t)0x0200)
     48          /* I2C Interrupt Enable mask */
     49          #define ITEN_Mask                   ((uint16_t)0x0700)
     50          /* I2C FLAG mask */
     51          #define FLAG_Mask                   ((uint16_t)0x00FF)
     52          /* I2C ADD0 mask */
     53          #define OAR1_ADD0_Set           ((uint8_t)0x01)
     54          #define OAR1_ADD0_Reset         ((uint8_t)0xFE)
     55          /**
     56            * @}
     57            */
     58          
     59          /** @defgroup I2C_Private_Macros
     60            * @{
     61            */
     62          
     63          /**
     64            * @}
     65            */
     66          
     67          /** @defgroup I2C_Private_Variables
     68            * @{
     69            */
     70          
     71          /**
     72            * @}
     73            */
     74          
     75          /** @defgroup I2C_Private_FunctionPrototypes
     76            * @{
     77            */
     78          
     79          /**
     80            * @}
     81            */
     82          
     83          /** @defgroup I2C_Private_Function
     84            * @{
     85            */
     86          
     87          /**
     88            * @}
     89            */
     90          
     91          /**
     92            * @addtogroup I2C_Public_Functions
     93            * @{
     94            */
     95          
     96          /**
     97            * @brief  Deinitializes the I2C peripheral registers to their default reset values.
     98            * @param  None
     99            * @retval None
    100            */
    101          void I2C_DeInit(I2C_TypeDef* I2Cx)
    102          {
    103            I2Cx->CR1 = I2C_CR1_RESET_VALUE;
    104            I2Cx->CR2 = I2C_CR2_RESET_VALUE;
    105            I2Cx->FREQR = I2C_FREQR_RESET_VALUE;
    106            I2Cx->OARL = I2C_OARL_RESET_VALUE;
    107            I2Cx->OARH = I2C_OARH_RESET_VALUE;
    108            I2Cx->OAR2 = I2C_OAR2_RESET_VALUE;
    109            I2Cx->ITR = I2C_ITR_RESET_VALUE;
    110            I2Cx->CCRL = I2C_CCRL_RESET_VALUE;
    111            I2Cx->CCRH = I2C_CCRH_RESET_VALUE;
    112            I2Cx->TRISER = I2C_TRISER_RESET_VALUE;
    113          }
    114          
    115          /**
    116            * @brief  Initializes the I2C according to the specified parameters in standard
    117            *         or fast mode.
    118            * @param  I2Cx : where x can be 1 to select the specified I2C peripheral.
    119            * @param  OutputClockFrequency : Specifies the output clock frequency in Hz.
    120            * @param  OwnAddress : Specifies the own address.
    121            * @param  I2C_Mode : Specifies the addressing mode to apply.
    122            *         This parameter can be any of the  @ref I2C_AddMode_TypeDef enumeration.
    123            * @param  I2C_DutyCycle : Specifies the duty cycle to apply in fast mode.
    124            *         This parameter can be any of the  @ref I2C_DutyCycle_TypeDef enumeration.
    125            * @note   This parameter don't have impact when the OutputClockFrequency lower
    126            *         than 100KHz.
    127            * @param  I2C_Ack : Specifies the acknowledge mode to apply.
    128            *         This parameter can be any of the  @ref I2C_Ack_TypeDef enumeration.
    129            * @param  I2C_AcknowledgedAddress : Specifies the acknowledge address to apply.
    130            *         This parameter can be any of the  @ref I2C_AcknowledgedAddress enumeration.
    131            * @retval None
    132            */
    133          void I2C_Init(I2C_TypeDef* I2Cx, uint32_t OutputClockFrequency, uint16_t OwnAddress,
    134                        I2C_Mode_TypeDef I2C_Mode, I2C_DutyCycle_TypeDef I2C_DutyCycle,
    135                        I2C_Ack_TypeDef I2C_Ack, I2C_AcknowledgedAddress_TypeDef I2C_AcknowledgedAddress)
    136          {
    137            uint32_t result = 0x0004;
    138            uint16_t tmpval = 0;
    139            uint8_t tmpccrh = 0;
    140            uint8_t input_clock = 0;
    141          
    142            /* Check the parameters */
    143            assert_param(IS_I2C_MODE(I2C_Mode));
    144            assert_param(IS_I2C_ACK_STATE(I2C_Ack));
    145            assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_AcknowledgedAddress));
    146            assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
    147            assert_param(IS_I2C_OWN_ADDRESS(OwnAddress));
    148            assert_param(IS_I2C_OUTPUT_CLOCK_FREQ(OutputClockFrequency));
    149          
    150          
    151            /* Get system clock frequency */
    152            input_clock = (uint8_t) (CLK_GetClockFreq() / 1000000);
    153          
    154            /*------------------------- I2C FREQ Configuration ------------------------*/
    155            /* Clear frequency bits */
    156            I2Cx->FREQR &= (uint8_t)(~I2C_FREQR_FREQ);
    157            /* Write new value */
    158            I2Cx->FREQR |= input_clock;
    159          
    160            /*--------------------------- I2C CCR Configuration ------------------------*/
    161            /* Disable I2C to configure TRISER */
    162            I2Cx->CR1 &= (uint8_t)(~I2C_CR1_PE);
    163          
    164            /* Clear CCRH & CCRL */
    165            I2Cx->CCRH &= (uint8_t)(~(I2C_CCRH_FS | I2C_CCRH_DUTY | I2C_CCRH_CCR));
    166            I2Cx->CCRL &= (uint8_t)(~I2C_CCRL_CCR);
    167          
    168            /* Detect Fast or Standard mode depending on the Output clock frequency selected */
    169            if (OutputClockFrequency > I2C_MAX_STANDARD_FREQ) /* FAST MODE */
    170            {
    171              /* Set F/S bit for fast mode */
    172              tmpccrh = I2C_CCRH_FS;
    173          
    174              if (I2C_DutyCycle == I2C_DutyCycle_2)
    175              {
    176                /* Fast mode speed calculate: Tlow/Thigh = 2 */
    177                result = (uint32_t) ((input_clock * 1000000) / (OutputClockFrequency * 3));
    178              }
    179              else /* I2C_DUTYCYCLE_16_9 */
    180              {
    181                /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
    182                result = (uint32_t) ((input_clock * 1000000) / (OutputClockFrequency * 25));
    183                /* Set DUTY bit */
    184                tmpccrh |= I2C_CCRH_DUTY;
    185              }
    186          
    187              /* Verify and correct CCR value if below minimum value */
    188              if (result < (uint16_t)0x01)
    189              {
    190                /* Set the minimum allowed value */
    191                result = (uint16_t)0x0001;
    192              }
    193          
    194              /* Set Maximum Rise Time: 300ns max in Fast Mode
    195              = [300ns/(1/input_clock.10e6)]+1
    196              = [(input_clock * 3)/10]+1 */
    197              tmpval = ((input_clock * 3) / 10) + 1;
    198              I2Cx->TRISER = (uint8_t)tmpval;
    199          
    200            }
    201            else /* STANDARD MODE */
    202            {
    203          
    204              /* Calculate standard mode speed */
    205              result = (uint16_t)((input_clock * 1000000) / (OutputClockFrequency << (uint8_t)1));
    206          
    207              /* Verify and correct CCR value if below minimum value */
    208              if (result < (uint16_t)0x0004)
    209              {
    210                /* Set the minimum allowed value */
    211                result = (uint16_t)0x0004;
    212              }
    213          
    214              /* Set Maximum Rise Time: 1000ns max in Standard Mode
    215              = [1000ns/(1/input_clock.10e6)]+1
    216              = input_clock+1 */
    217              I2Cx->TRISER = (uint8_t)((uint8_t)input_clock + (uint8_t)1);
    218          
    219            }
    220          
    221            /* Write CCR with new calculated value */
    222            I2Cx->CCRL = (uint8_t)result;
    223            I2Cx->CCRH = (uint8_t)((uint8_t)((uint8_t)((uint8_t)result >> 8) & I2C_CCRH_CCR) | tmpccrh);
    224          
    225            /* Enable I2C and  Cofigure its mode*/
    226            I2Cx->CR1 |= (uint8_t)(I2C_CR1_PE | I2C_Mode);
    227          
    228            /* Configure I2C acknowledgement */
    229            I2Cx->CR2 |= (uint8_t)I2C_Ack;
    230          
    231            /*--------------------------- I2C OAR Configuration ------------------------*/
    232            I2Cx->OARL = (uint8_t)(OwnAddress);
    233            I2Cx->OARH = (uint8_t)((uint8_t)(I2C_AcknowledgedAddress | I2C_OARH_ADDCONF ) | \
    234                                   (uint8_t)((uint16_t)( (uint16_t)OwnAddress &  (uint16_t)0x0300) >> 7));
    235          }
    236          
    237          /**
    238            * @brief  Enables or disables the I2C peripheral.
    239            * @param  I2Cx : where x can be 1 to select the specified I2C peripheral.
    240            * @param  NewState : Indicate the new I2C peripheral state.
    241            *         This parameter can be any of the @ref FunctionalState enumeration.
    242            * @retval None
    243            */
    244          void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    245          {
    246          
    247            /* Check function parameters */
    248            assert_param(IS_FUNCTIONAL_STATE(NewState));
    249          
    250            if (NewState != DISABLE)
    251            {
    252              /* Enable I2C peripheral */
    253              I2Cx->CR1 |= I2C_CR1_PE;
    254            }
    255            else /* NewState == DISABLE */
    256            {
    257              /* Disable I2C peripheral */
    258              I2Cx->CR1 &= (uint8_t)(~I2C_CR1_PE);
    259            }
    260          }
    261          /**
    262            * @brief  Enables or disables the specified I2C interrupt.
    263            * @param  I2Cx : where x can be 1 to select the specified I2C peripheral.
    264            * @param  I2C_IT : Name of the interrupt to enable or disable.
    265            *         This parameter can be any of the  @ref I2C_IT_TypeDef enumeration.
    266            * @param  NewState : State of the interrupt.
    267            *         This parameter can be any of the @ref FunctionalState enumeration.
    268            * @retval None
    269            */
    270          void I2C_ITConfig(I2C_TypeDef* I2Cx, I2C_IT_TypeDef I2C_IT, FunctionalState NewState)
    271          {
    272            /* Check functions parameters */
    273            assert_param(IS_I2C_CONFIG_IT(I2C_IT));
    274            assert_param(IS_FUNCTIONAL_STATE(NewState));
    275          
    276            if (NewState != DISABLE)
    277            {
    278              /* Enable the selected I2C interrupts */
    279              I2Cx->ITR |= (uint8_t)I2C_IT;
    280            }
    281            else /* NewState == DISABLE */
    282            {
    283              /* Disable the selected I2C interrupts */
    284              I2Cx->ITR &= (uint8_t)(~(uint8_t)I2C_IT);
    285            }
    286          }
    287          /**
    288            * @brief  Enables or disables the I2C DMA requests .
    289            * @param  I2Cx : where x can be 1 to select the specified I2C peripheral.
    290            * @param  NewState : Indicate the new I2C DMA state.
    291            *         This parameter can be any of the @ref FunctionalState enumeration.
    292            * @retval None
    293            */
    294          void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    295          {
    296            /* Check the parameters */
    297            assert_param(IS_FUNCTIONAL_STATE(NewState));
    298          
    299            if (NewState != DISABLE)
    300            {
    301              /* Enable I2C DMA requests */
    302              I2Cx->ITR |= I2C_ITR_DMAEN;
    303            }
    304            else
    305            {
    306              /* Disable I2C DMA requests */
    307              I2Cx->ITR &= (uint8_t)(~I2C_ITR_DMAEN);
    308            }
    309          }
    310          
    311          /**
    312            * @brief  Specifies that the next DMA transfer is the last one .
    313            * @param  I2Cx : where x can be 1 to select the specified I2C peripheral.
    314            * @param  NewState : Indicate the new I2C DMA state.
    315            *         This parameter can be any of the @ref FunctionalState enumeration.
    316            * @retval None
    317            */
    318          void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    319          {
    320            /* Check the parameters */
    321            assert_param(IS_FUNCTIONAL_STATE(NewState));
    322          
    323            if (NewState != DISABLE)
    324            {
    325              /* Enable I2C DMA requests */
    326              I2Cx->ITR |= I2C_ITR_LAST;
    327            }
    328            else
    329            {
    330              /* Disable I2C DMA requests */
    331              I2Cx->ITR &= (uint8_t)(~I2C_ITR_LAST);
    332            }
    333          }
    334          
    335          /**
    336            * @brief  Enables or disables the I2C General Call feature.
    337            * @param  I2Cx : where x can be 1 to select the specified I2C peripheral.
    338            * @param  NewState : State of the General Call feature.
    339            *         This parameter can be any of the @ref FunctionalState enumeration.
    340            * @retval None
    341            */
    342          void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    343          {
    344          
    345            /* Check function parameters */
    346            assert_param(IS_FUNCTIONAL_STATE(NewState));
    347          
    348            if (NewState != DISABLE)
    349            {
    350              /* Enable General Call */
    351              I2Cx->CR1 |= I2C_CR1_ENGC;
    352            }
    353            else /* NewState == DISABLE */
    354            {
    355              /* Disable General Call */
    356              I2Cx->CR1 &= (uint8_t)(~I2C_CR1_ENGC);
    357            }
    358          }
    359          
    360          /**
    361            * @brief  Generates I2C communication START condition.
    362            * @note   CCR must be programmed, i.e. I2C_Init function must have been called
    363            *         with a valid I2C_ClockSpeed
    364            * @param  I2Cx : where x can be 1 to select the specified I2C peripheral.
    365            * @param  NewState : Enable or disable the start condition.
    366            *         This parameter can be any of the @ref FunctionalState enumeration.
    367            * @retval None
    368            */
    369          void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
    370          {
    371          
    372            /* Check function parameters */
    373            assert_param(IS_FUNCTIONAL_STATE(NewState));
    374          
    375            if (NewState != DISABLE)
    376            {
    377              /* Generate a START condition */
    378              I2Cx->CR2 |= I2C_CR2_START;
    379            }
    380            else /* NewState == DISABLE */
    381            {
    382              /* Disable the START condition generation */
    383              I2Cx->CR2 &= (uint8_t)(~I2C_CR2_START);
    384            }
    385          }
    386          
    387          /**
    388            * @brief  Generates I2C communication STOP condition.
    389            * @param  I2Cx : where x can be 1 to select the specified I2C peripheral.
    390            * @param  NewState : Enable or disable the stop condition.
    391            *         This parameter can be any of the @ref FunctionalState enumeration.
    392            * @retval None
    393            */
    394          void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
    395          {
    396          
    397            /* Check function parameters */
    398            assert_param(IS_FUNCTIONAL_STATE(NewState));
    399          
    400            if (NewState != DISABLE)
    401            {
    402              /* Generate a STOP condition */
    403              I2Cx->CR2 |= I2C_CR2_STOP;
    404            }
    405            else /* NewState == DISABLE */
    406            {
    407              /* Disable the STOP condition generation */
    408              I2Cx->CR2 &= (uint8_t)(~I2C_CR2_STOP);
    409            }
    410          }
    411          
    412          /**
    413            * @brief  Enables or disables I2C software reset.
    414            * @param  I2Cx : where x can be 1 to select the specified I2C peripheral.
    415            * @param  NewState : Specifies the new state of the I2C software reset.
    416            *         This parameter can be any of the @ref FunctionalState enumeration.
    417            * @retval None
    418            */
    419          void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    420          {
    421            /* Check function parameters */
    422            assert_param(IS_FUNCTIONAL_STATE(NewState));
    423          
    424            if (NewState != DISABLE)
    425            {
    426              /* Peripheral under reset */
    427              I2Cx->CR2 |= I2C_CR2_SWRST;
    428            }
    429            else /* NewState == DISABLE */
    430            {
    431              /* Peripheral not under reset */
    432              I2Cx->CR2 &= (uint8_t)(~I2C_CR2_SWRST);
    433            }
    434          }
    435          
    436          /**
    437            * @brief  Enables or disables the I2C clock stretching.
    438            * @param  I2Cx : where x can be 1 to select the specified I2C peripheral.
    439            * @param  NewState : Specifies the new state of the I2C Clock stretching.
    440            *         This parameter can be any of the @ref FunctionalState enumeration.
    441            * @retval None
    442            */
    443          void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    444          {
    445            /* Check function parameters */
    446            assert_param(IS_FUNCTIONAL_STATE(NewState));
    447          
    448            if (NewState != DISABLE)
    449            {
    450              /* Clock Stretching Enable */
    451              I2Cx->CR1 &= (uint8_t)(~I2C_CR1_NOSTRETCH);
    452          
    453            }
    454            else /* NewState == DISABLE */
    455            {
    456              /* Clock Stretching Disable (Slave mode) */
    457              I2Cx->CR1 |= I2C_CR1_NOSTRETCH;
    458            }
    459          }
    460          
    461          /**
    462            * @brief  Enables or disables the I2C ARP.
    463            * @param  I2Cx : where x can be 1 to select the specified I2C peripheral.
    464            * @param  NewState : Specifies the new state of the I2C ARP
    465            *         This parameter can be any of the @ref FunctionalState enumeration.
    466            * @retval None
    467            */
    468          void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    469          {
    470            /* Check function parameters */
    471            assert_param(IS_FUNCTIONAL_STATE(NewState));
    472          
    473            if (NewState != DISABLE)
    474            {
    475              /* ARP Enable */
    476              I2Cx->CR1 |= I2C_CR1_ARP;
    477          
    478            }
    479            else /* NewState == DISABLE */
    480            {
    481              /* ARP Disable  */
    482              I2Cx->CR1 &= (uint8_t)(~I2C_CR1_ARP);
    483            }
    484          }
    485          
    486          /**
    487            * @brief  Enable or Disable the I2C acknowledge feature.
    488            * @param  I2Cx : where x can be 1 to select the specified I2C peripheral.
    489            * @param  NewState : Specifies the new state of the I2C acknowledge.
    490            *         This parameter can be any of the @ref FunctionalState enumeration.
    491            * @retval None
    492            */
    493          void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
    494          {
    495            /* Check function parameters */
    496            assert_param(IS_FUNCTIONAL_STATE(NewState));
    497          
    498            if (NewState != DISABLE)
    499            {
    500              /* Enable the acknowledgement */
    501              I2Cx->CR2 |= I2C_CR2_ACK;
    502            }
    503            else
    504            {
    505              /* Disable the acknowledgement */
    506              I2Cx->CR2 &= (uint8_t)(~I2C_CR2_ACK);
    507            }
    508          }
    509          
    510          /**
    511            * @brief  Configures the specified I2C own address2.
    512            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    513            * @param  Address: specifies the 7bit I2C own address2.
    514            * @retval None.
    515            */
    516          void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, uint8_t Address)
    517          {
    518            uint8_t tmpreg = 0;
    519          
    520            /* Get the old register value */
    521            tmpreg = I2Cx->OAR2;
    522          
    523            /* Reset I2Cx Own address2 bit [7:1] */
    524            tmpreg &= (uint8_t)(~I2C_OAR2_ADD2);
    525          
    526            /* Set I2Cx Own address2 */
    527            tmpreg |= (uint8_t) ((uint8_t)Address & (uint8_t)0xFE);
    528          
    529            /* Store the new register value */
    530            I2Cx->OAR2 = tmpreg;
    531          }
    532          
    533          /**
    534            * @brief  Enables or disables the specified I2C dual addressing mode.
    535            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    536            * @param  NewState: new state of the I2C dual addressing mode.
    537            *         This parameter can be: ENABLE or DISABLE.
    538            * @retval None
    539            */
    540          void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    541          {
    542            /* Check the parameters */
    543            assert_param(IS_FUNCTIONAL_STATE(NewState));
    544          
    545            if (NewState != DISABLE)
    546            {
    547              /* Enable dual addressing mode */
    548              I2Cx->OAR2 |= I2C_OAR2_ENDUAL;
    549            }
    550            else
    551            {
    552              /* Disable dual addressing mode */
    553              I2Cx->OAR2 &= (uint8_t)(~I2C_OAR2_ENDUAL);
    554            }
    555          }
    556          
    557          /**
    558            * @brief  Selects the specified I2C Ack position.
    559            * @note   This function must be called before data reception starts.
    560            * @param  I2Cx : where x can be 1 to select the specified I2C peripheral.
    561            * @param  I2C_AckPosition: specifies the Ack position.
    562            *         This parameter can be any of the @ref I2C_AckPosition_TypeDef enumeration.
    563            * @retval None
    564            */
    565          void I2C_AckPositionConfig(I2C_TypeDef* I2Cx, I2C_AckPosition_TypeDef I2C_AckPosition)
    566          {
    567            /* Check function parameters */
    568            assert_param(IS_I2C_ACK_POSITION(I2C_AckPosition));
    569          
    570            /* Clear the I2C Ack position */
    571            I2Cx->CR2 &= (uint8_t)(~I2C_CR2_POS);
    572            /* Configure the specified I2C Ack position*/
    573            I2Cx->CR2 |= (uint8_t)I2C_AckPosition;
    574          }
    575          
    576          /**
    577            * @brief  Selects I2C PEC position..
    578            * @param  I2Cx : where x can be 1 to select the specified I2C peripheral.
    579            * @param  I2C_PECPosition :PEC position.
    580            *         This parameter can be any of the  @ref I2C_PECPosition_TypeDef
    581            *         enumeration.
    582            * @retval None
    583            */
    584          void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, I2C_PECPosition_TypeDef I2C_PECPosition)
    585          {
    586            /* Check the parameters */
    587            assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
    588          
    589            /* Clear the I2C PEC position */
    590            I2Cx->CR2 &= (uint8_t)(~I2C_CR2_POS);
    591            /* Configure the specified I2C PEC position*/
    592            I2Cx->CR2 |= (uint8_t)I2C_PECPosition;
    593          }
    594          /**
    595            * @brief  Drives the SMBusAlert pin high or low.
    596            * @param  I2Cx : where x can be 1 to select the specified I2C peripheral.
    597            * @param  I2C_SMBusAlert : SMBusAlert pin state.
    598            *         This parameter can be any of the  @ref I2C_SMBusAlert_TypeDef
    599            *         enumeration.
    600            * @retval None
    601            */
    602          void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, I2C_SMBusAlert_TypeDef I2C_SMBusAlert)
    603          {
    604          
    605            /* Check functions parameters */
    606            assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
    607          
    608            if (I2C_SMBusAlert != I2C_SMBusAlert_High)
    609            {
    610              /* SMBus Alert pin low */
    611              I2Cx->CR2 |= (uint8_t)I2C_CR2_ALERT;
    612            }
    613            else /*I2C_SMBusAlert = I2C_SMBusAlert_High */
    614            {
    615              /* SMBus Alert pin high */
    616              I2Cx->CR2 &= (uint8_t)(~I2C_CR2_ALERT);
    617            }
    618          }
    619          
    620          /**
    621            * @brief  Enables or disables PEC transfer.
    622            * @param  I2Cx : where x can be 1 to select the specified I2C peripheral.
    623            * @param  NewState : indicates the PEC  transfer state.
    624            *         This parameter can be any of the @ref FunctionalState enumeration.
    625            * @retval None
    626            */
    627          void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
    628          {
    629            /* Check the parameters */
    630            assert_param(IS_FUNCTIONAL_STATE(NewState));
    631          
    632            if (NewState != DISABLE)
    633            {
    634              /* Enable the PEC transmission */
    635              I2Cx->CR2 |= I2C_CR2_PEC;
    636            }
    637            else
    638            {
    639              /* Disable the PEC transmission */
    640              I2Cx->CR2 &= (uint8_t)(~I2C_CR2_PEC);
    641            }
    642          }
    643          
    644          /**
    645            * @brief  Enables or disables PEC calculation.
    646            * @param  I2Cx : where x can be 1 to select the specified I2C peripheral.
    647            * @param  NewState : indicates the PEC  calculation state.
    648            *         This parameter can be any of the @ref FunctionalState enumeration.
    649            * @retval None
    650            */
    651          void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
    652          {
    653            /* Check the parameters */
    654            assert_param(IS_FUNCTIONAL_STATE(NewState));
    655          
    656            if (NewState != DISABLE)
    657            {
    658              /* Enable PEC calculation */
    659              I2Cx->CR1 |= I2C_CR1_ENPEC;
    660            }
    661            else
    662            {
    663              /* Disable PEC calculation */
    664              I2Cx->CR1 &= (uint8_t)(~I2C_CR1_ENPEC);
    665            }
    666          }
    667          
    668          /**
    669            * @brief  Selects I2C fast mode duty cycle.
    670            * @param  I2Cx : where x can be 1 to select the specified I2C peripheral.
    671            * @param  I2C_DutyCycle : Specifies the duty cycle to apply.
    672            *         This parameter can be any of the @ref I2C_DutyCycle_TypeDef
    673            *         enumeration.
    674            * @retval None
    675            */
    676          void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, I2C_DutyCycle_TypeDef I2C_DutyCycle)
    677          {
    678          
    679            /* Check function parameters */
    680            assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
    681          
    682            if (I2C_DutyCycle == I2C_DutyCycle_16_9)
    683            {
    684              /* I2C fast mode Tlow/Thigh = 16/9 */
    685              I2Cx->CCRH |= I2C_CCRH_DUTY;
    686            }
    687            else /* I2C_DUTYCYCLE_2 */
    688            {
    689              /* I2C fast mode Tlow/Thigh = 2 */
    690              I2Cx->CCRH &= (uint8_t)(~I2C_CCRH_DUTY);
    691            }
    692          }
    693          
    694          /**
    695            * @brief  Returns the most recent received data.
    696            * @param  I2Cx : where x can be 1 to select the specified I2C peripheral.
    697            * @param  None
    698            * @retval The value of the received byte data.
    699            */
    700          uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
    701          {
    702            /* Return the data present in the DR register */
    703            return ((uint8_t)I2Cx->DR);
    704          }
    705          
    706          /**
    707            * @brief  Transmits the 7-bit address (to select the) slave device.
    708            * @param  I2Cx : where x can be 1 to select the specified I2C peripheral.
    709            * @param  Address : Specifies the slave address which will be transmitted.
    710            * @param  I2C_Direction : Specifies whether the I2C device will be a Transmitter
    711            *         or a Receiver.
    712            *         This parameter can be any of the @ref I2C_Direction_TypeDef enumeration.
    713            * @retval None
    714            */
    715          void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, I2C_Direction_TypeDef I2C_Direction)
    716          {
    717            /* Check function parameters */
    718            assert_param(IS_I2C_ADDRESS(Address));
    719            assert_param(IS_I2C_DIRECTION(I2C_Direction));
    720          
    721            /* Test on the direction to set/reset the read/write bit */
    722            if (I2C_Direction != I2C_Direction_Transmitter)
    723            {
    724              /* Set the address bit0 for read */
    725              Address |= OAR1_ADD0_Set;
    726            }
    727            else
    728            {
    729              /* Reset the address bit0 for write */
    730              Address &= OAR1_ADD0_Reset;
    731            }
    732            /* Send the address */
    733            I2Cx->DR = Address;
    734          }
    735          
    736          /**
    737            * @brief  Send a byte by writing in the DR register.
    738            * @param  I2Cx : where x can be 1 to select the specified I2C peripheral.
    739            * @param  Data : Byte to be sent.
    740            * @retval None
    741            */
    742          void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
    743          {
    744            /* Write in the DR register the data to be sent */
    745            I2Cx->DR = Data;
    746          }
    747          
    748          /**
    749            * @brief  Returns PEC value.
    750            * @param  I2Cx : where x can be 1 to select the specified I2C peripheral.
    751            * @param  None
    752            * @retval The value of the PEC.
    753            */
    754          uint8_t I2C_GetPEC(I2C_TypeDef* I2Cx)
    755          {
    756            /* Return the PEC value */
    757            return (I2Cx->PECR);
    758          }
    759          
    760          /**
    761            * @brief  Reads the specified I2C register and returns its value.
    762            * @param  I2Cx : where x can be 1 to select the specified I2C peripheral.
    763            * @param  I2C_Register: specifies the register to read.
    764            *         This parameter can be any of the @ref I2C_Register_TypeDef enumeration.
    765            * @retval The value of the read register.
    766            */
    767          
    768          uint8_t I2C_ReadRegister(I2C_TypeDef* I2Cx, I2C_Register_TypeDef I2C_Register)
    769          {
    770            __IO uint16_t tmp = 0;
    771            /* Check the parameters */
    772            assert_param(IS_I2C_REGISTER(I2C_Register));
    773          
    774            tmp = (uint16_t) I2Cx;
    775            tmp += I2C_Register;
    776          
    777            /* Return the selected register value */
    778            return (*(__IO uint8_t *) tmp);
    779          }
    780          /**
    781           * @brief
    782           ****************************************************************************************
    783           *
    784           *                         I2C State Monitoring Functions
    785           *
    786           ****************************************************************************************
    787           * This I2C driver provides three different ways for I2C state monitoring
    788           *  depending on the application requirements and constraints:
    789           *
    790           *
    791           * 1) Basic state monitoring:
    792           *    Using I2C_CheckEvent() function:
    793           *    It compares the status registers (SR1, SR2 and SR3) content to a given event
    794           *    (can be the combination of one or more flags).
    795           *    It returns SUCCESS if the current status includes the given flags
    796           *    and returns ERROR if one or more flags are missing in the current status.
    797           *    - When to use:
    798           *      - This function is suitable for most applications as well as for startup
    799           *      activity since the events are fully described in the product reference manual
    800           *      (RM0031).
    801           *      - It is also suitable for users who need to define their own events.
    802           *    - Limitations:
    803           *      - If an error occurs (ie. error flags are set besides to the monitored flags),
    804           *        the I2C_CheckEvent() function may return SUCCESS despite the communication
    805           *        hold or corrupted real state.
    806           *        In this case, it is advised to use error interrupts to monitor the error
    807           *        events and handle them in the interrupt IRQ handler.
    808           *
    809           *        @note
    810           *        For error management, it is advised to use the following functions:
    811           *          - I2C_ITConfig() to configure and enable the error interrupts (I2C_IT_ERR).
    812           *          - I2Cx_IRQHandler() which is called when the I2C interurpts occur.
    813           *            Where x is the peripheral instance (I2C1,...)
    814           *          - I2C_GetFlagStatus() or I2C_GetITStatus() to be called into the
    815           *           I2Cx_IRQHandler() function in order to determine which error occured.
    816           *          - I2C_ClearFlag() or I2C_ClearITPendingBit() and/or I2C_SoftwareResetCmd()
    817           *            and/or I2C_GenerateStop() in order to clear the error flag and
    818           *            source and return to correct communication status.
    819           *
    820           *
    821           *  2) Advanced state monitoring:
    822           *     Using the function I2C_GetLastEvent() which returns the image of both SR1
    823           *     & SR3 status registers in a single word (uint16_t) (Status Register 3 value
    824           *     is shifted left by 8 bits and concatenated to Status Register 1).
    825           *     - When to use:
    826           *       - This function is suitable for the same applications above but it allows to
    827           *         overcome the limitations of I2C_GetFlagStatus() function (see below).
    828           *         The returned value could be compared to events already defined in the
    829           *         library (stm8l15x_i2c.h) or to custom values defined by user.
    830           *       - This function is suitable when multiple flags are monitored at the same time.
    831           *       - At the opposite of I2C_CheckEvent() function, this function allows user to
    832           *         choose when an event is accepted (when all events flags are set and no
    833           *         other flags are set or just when the needed flags are set like
    834           *         I2C_CheckEvent() function).
    835           *     - Limitations:
    836           *       - User may need to define his own events.
    837           *       - Same remark concerning the error management is applicable for this
    838           *         function if user decides to check only regular communication flags (and
    839           *         ignores error flags).
    840           *
    841           *
    842           *  3) Flag-based state monitoring:
    843           *     Using the function I2C_GetFlagStatus() which simply returns the status of
    844           *     one single flag (ie. I2C_FLAG_RXNE ...).
    845           *     - When to use:
    846           *        - This function could be used for specific applications or in debug phase.
    847           *        - It is suitable when only one flag checking is needed (most I2C events
    848           *          are monitored through multiple flags).
    849           *     - Limitations:
    850           *        - When calling this function, the Status register is accessed. Some flags are
    851           *          cleared when the status register is accessed. So checking the status
    852           *          of one Flag, may clear other ones.
    853           *        - Function may need to be called twice or more in order to monitor one
    854           *          single event.
    855           *
    856           *  For detailed description of Events, please refer to section I2C_Events in
    857           *  stm8l15x_i2c.h file.
    858           *
    859           */
    860          /**
    861           *
    862           *  1) Basic state monitoring
    863           *******************************************************************************
    864           */
    865          
    866          /**
    867            * @brief  Checks whether the last I2Cx Event is equal to the one passed
    868            *   as parameter.
    869            * @param  I2Cx: where x can be 1 to select the I2C peripheral.
    870            * @param  I2C_EVENT: specifies the event to be checked.
    871            *   This parameter can be one of the following values:
    872            *     @arg I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED           : EV1
    873            *     @arg I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED              : EV1
    874            *     @arg I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED            : EV1
    875            *     @arg I2C_EVENT_SLAVE_BYTE_RECEIVED                         : EV2
    876            *     @arg (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_GENCALL)    : EV2
    877            *     @arg I2C_EVENT_SLAVE_BYTE_TRANSMITTED                      : EV3
    878            *     @arg (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_GENCALL) : EV3
    879            *     @arg I2C_EVENT_SLAVE_ACK_FAILURE                           : EV3_2
    880            *     @arg I2C_EVENT_SLAVE_STOP_DETECTED                         : EV4
    881            *     @arg I2C_EVENT_MASTER_MODE_SELECT                          : EV5
    882            *     @arg I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED            : EV6
    883            *     @arg I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED               : EV6
    884            *     @arg I2C_EVENT_MASTER_BYTE_RECEIVED                        : EV7
    885            *     @arg I2C_EVENT_MASTER_BYTE_TRANSMITTING                    : EV8
    886            *     @arg I2C_EVENT_MASTER_BYTE_TRANSMITTED                     : EV8_2
    887            *     @arg I2C_EVENT_MASTER_MODE_ADDRESS10                       : EV9
    888            *
    889            * @note: For detailed description of Events, please refer to section
    890            *    I2C_Events in stm8l15x_i2c.h file.
    891            *
    892            * @retval An ErrorStatus enumuration value:
    893            * - SUCCESS: Last event is equal to the I2C_EVENT
    894            * - ERROR: Last event is different from the I2C_EVENT
    895            */
    896          ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, I2C_Event_TypeDef I2C_Event)
    897          {
    898            __IO uint16_t lastevent = 0x00;
    899            uint8_t flag1 = 0x00 ;
    900            uint8_t flag2 = 0x00;
    901            ErrorStatus status = ERROR;
    902          
    903            /* Check the parameters */
    904            assert_param(IS_I2C_EVENT(I2C_Event));
    905          
    906            if (I2C_Event == I2C_EVENT_SLAVE_ACK_FAILURE)
    907            {
    908              lastevent = I2Cx->SR2 & I2C_SR2_AF;
    909            }
    910            else
    911            {
    912              flag1 = I2Cx->SR1;
    913              flag2 = I2Cx->SR3;
    914              lastevent = ((uint16_t)((uint16_t)flag2 << (uint16_t)8) | (uint16_t)flag1);
    915            }
    916            /* Check whether the last event is equal to I2C_EVENT */
    917            if (((uint16_t)lastevent & (uint16_t)I2C_Event) == (uint16_t)I2C_Event)
    918            {
    919              /* SUCCESS: last event is equal to I2C_EVENT */
    920              status = SUCCESS;
    921            }
    922            else
    923            {
    924              /* ERROR: last event is different from I2C_EVENT */
    925              status = ERROR;
    926            }
    927          
    928            /* Return status */
    929            return status;
    930          }
    931          
    932          /**
    933           *
    934           *  2) Advanced state monitoring
    935           *******************************************************************************
    936           */
    937          /**
    938            * @brief  Returns the last I2C Event.
    939            * @param  I2Cx : where x can be 1 to select the specified I2C peripheral.
    940            *
    941            * @note: For detailed description of Events, please refer to section
    942            *    I2C_Events in stm8l15xx_i2c.h file.
    943            *
    944            * @retval The last event
    945            *   This parameter can be any of the  @ref I2C_Event_TypeDef enumeration.
    946            */
    947          I2C_Event_TypeDef I2C_GetLastEvent(I2C_TypeDef* I2Cx)
    948          {
    949            __IO uint16_t lastevent = 0;
    950            uint16_t flag1 = 0;
    951            uint16_t flag2 = 0;
    952          
    953            if ((I2Cx->SR2 & I2C_SR2_AF) != 0x00)
    954            {
    955              lastevent = I2C_EVENT_SLAVE_ACK_FAILURE;
    956            }
    957            else
    958            {
    959              /* Read the I2C status register */
    960              flag1 = I2Cx->SR1;
    961              flag2 = I2Cx->SR3;
    962          
    963              /* Get the last event value from I2C status register */
    964              lastevent = ((uint16_t)((uint16_t)flag2 << 8) | (uint16_t)flag1);
    965            }
    966            /* Return status */
    967            return (I2C_Event_TypeDef)lastevent;
    968          }
    969          
    970          /**
    971           *
    972           *  3) Flag-based state monitoring
    973           *******************************************************************************
    974           */
    975          /**
    976            * @brief  Checks whether the specified I2C flag is set or not.
    977            * @param  I2Cx: where x can be 1 select the I2C peripheral.
    978            * @param  I2C_FLAG: specifies the flag to check.
    979            *   This parameter can be one of the following values:
    980            *     @arg I2C_FLAG_SMBHOST: SMBus host header (Slave mode)
    981            *     @arg I2C_FLAG_SMBDEFAULT: SMBus default header (Slave mode)
    982            *     @arg I2C_FLAG_GENCALL: General call header flag (Slave mode)
    983            *     @arg I2C_FLAG_TRA: Transmitter/Receiver flag
    984            *     @arg I2C_FLAG_BUSY: Bus busy flag
    985            *     @arg I2C_FLAG_MSL: Master/Slave flag
    986            *     @arg I2C_FLAG_SMBALERT: SMBus Alert flag
    987            *     @arg I2C_FLAG_TIMEOUT: Timeout or Tlow error flag
    988            *     @arg I2C_FLAG_PECERR: PEC error in reception flag
    989            *     @arg I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode)
    990            *     @arg I2C_FLAG_AF: Acknowledge failure flag
    991            *     @arg I2C_FLAG_ARLO: Arbitration lost flag (Master mode)
    992            *     @arg I2C_FLAG_BERR: Bus error flag
    993            *     @arg I2C_FLAG_TXE: Data register empty flag (Transmitter)
    994            *     @arg I2C_FLAG_RXNE: Data register not empty (Receiver) flag
    995            *     @arg I2C_FLAG_STOPF: Stop detection flag (Slave mode)
    996            *     @arg I2C_FLAG_ADD10: 10-bit header sent flag (Master mode)
    997            *     @arg I2C_FLAG_BTF: Byte transfer finished flag
    998            *     @arg I2C_FLAG_ADDR: Address sent flag (Master mode) ADSL
    999            *   Address matched flag (Slave mode)ENDAD
   1000            *     @arg I2C_FLAG_SB: Start bit flag (Master mode)
   1001            * @retval The new state of I2C_FLAG (SET or RESET).
   1002            */
   1003          FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, I2C_FLAG_TypeDef I2C_FLAG)
   1004          {
   1005            uint8_t tempreg = 0;
   1006            uint8_t regindex = 0;
   1007            FlagStatus bitstatus = RESET;
   1008          
   1009            /* Check the parameters */
   1010            assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
   1011          
   1012            /* Read flag register index */
   1013            regindex = (uint8_t)((uint16_t)I2C_FLAG >> 8);
   1014            /* Check SRx index */
   1015            switch (regindex)
   1016            {
   1017                /* Returns whether the status register to check is SR1 */
   1018              case 0x01:
   1019                tempreg = (uint8_t)I2Cx->SR1;
   1020                break;
   1021          
   1022                /* Returns whether the status register to check is SR2 */
   1023              case 0x02:
   1024                tempreg = (uint8_t)I2Cx->SR2;
   1025                break;
   1026          
   1027                /* Returns whether the status register to check is SR3 */
   1028              case 0x03:
   1029                tempreg = (uint8_t)I2Cx->SR3;
   1030                break;
   1031          
   1032              default:
   1033                break;
   1034            }
   1035          
   1036            /* Check the status of the specified I2C flag */
   1037            if ((tempreg & (uint8_t)I2C_FLAG ) != 0)
   1038            {
   1039              /* Flag is set */
   1040              bitstatus = SET;
   1041            }
   1042            else
   1043            {
   1044              /* Flag is reset */
   1045              bitstatus = RESET;
   1046            }
   1047            /* Return the flag status */
   1048            return bitstatus;
   1049          }
   1050          /**
   1051            * @brief  Clear flags
   1052            * @param  I2Cx : where x can be 1 to select the specified I2C peripheral.
   1053            * @param  I2C_Flag : Specifies the flag to clear
   1054            *   This parameter can be any combination of the following values:
   1055            *                       - I2C_FLAG_SMBALERT: SMBus Alert flag
   1056            *                       - I2C_FLAG_TIMEOUT: Timeout or Tlow error flag
   1057            *                       - I2C_FLAG_PECERR: PEC error in reception flag
   1058            *                       - I2C_FLAG_WUFH: Wakeup from Halt
   1059            *                       - I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode)
   1060            *                       - I2C_FLAG_AF: Acknowledge failure flag
   1061            *                       - I2C_FLAG_ARLO: Arbitration lost flag (Master mode)
   1062            *                       - I2C_FLAG_BERR: Bus error flag.
   1063            * @note Notes:
   1064            *                       - STOPF (STOP detection) is cleared by software
   1065            *                         sequence: a read operation to I2C_SR1 register
   1066            *                         (I2C_GetFlagStatus()) followed by a write operation
   1067            *                         to I2C_CR2 register.
   1068            *                       - ADD10 (10-bit header sent) is cleared by software
   1069            *                         sequence: a read operation to I2C_SR1
   1070            *                         (I2C_GetFlagStatus()) followed by writing the
   1071            *                         second byte of the address in DR register.
   1072            *                       - BTF (Byte Transfer Finished) is cleared by software
   1073            *                         sequence: a read operation to I2C_SR1 register
   1074            *                         (I2C_GetFlagStatus()) followed by a read/write to
   1075            *                         I2C_DR register (I2C_SendData()).
   1076            *                       - ADDR (Address sent) is cleared by software sequence:
   1077            *                         a read operation to I2C_SR1 register
   1078            *                         (I2C_GetFlagStatus()) followed by a read operation to
   1079            *                         I2C_SR3 register ((void)(I2Cx->SR3)).
   1080            *                       - SB (Start Bit) is cleared software sequence: a read
   1081            *                         operation to I2C_SR1 register (I2C_GetFlagStatus())
   1082            *                         followed by a write operation to I2C_DR reigister
   1083            *                         (I2C_SendData()).
   1084            * @retval None
   1085            */
   1086          void I2C_ClearFlag(I2C_TypeDef* I2Cx, I2C_FLAG_TypeDef I2C_FLAG)
   1087          {
   1088            uint16_t flagpos = 0;
   1089            /* Check the parameters */
   1090            assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
   1091          
   1092            /* Get the I2C flag position */
   1093            flagpos = (uint16_t)I2C_FLAG & FLAG_Mask;
   1094            /* Clear the selected I2C flag */
   1095            I2Cx->SR2 = (uint8_t)((uint16_t)(~flagpos));
   1096          }
   1097          
   1098          /**
   1099            * @brief  Checks whether the specified I2C interrupt has occurred or not.
   1100            * @param  I2Cx : where x can be 1 to select the specified I2C peripheral.
   1101            * @param  I2C_IT: specifies the interrupt source to check.
   1102            *            This parameter can be one of the following values:
   1103            *               - I2C_IT_SMBALERT: SMBus Alert interrupt
   1104            *               - I2C_IT_TIMEOUT: Timeout or Tlow error interrupt
   1105            *               - I2C_IT_PECERR: PEC error in reception  interrupt
   1106            *               - I2C_IT_WUFH: Wakeup from Halt
   1107            *               - I2C_IT_OVR: Overrun/Underrun flag (Slave mode)
   1108            *               - I2C_IT_AF: Acknowledge failure flag
   1109            *               - I2C_IT_ARLO: Arbitration lost flag (Master mode)
   1110            *               - I2C_IT_BERR: Bus error flag
   1111            *               - I2C_IT_TXE: Data register empty flag (Transmitter)
   1112            *               - I2C_IT_RXNE: Data register not empty (Receiver) flag
   1113            *               - I2C_IT_STOPF: Stop detection flag (Slave mode)
   1114            *               - I2C_IT_ADD10: 10-bit header sent flag (Master mode)
   1115            *               - I2C_IT_BTF: Byte transfer finished flag
   1116            *               - I2C_IT_ADDR: Address sent flag (Master mode) ADSL
   1117            *                              Address matched flag (Slave mode)ENDAD
   1118            *               - I2C_IT_SB: Start bit flag (Master mode)
   1119            * @retval The new state of I2C_IT
   1120            *   This parameter can be any of the @ref ITStatus enumeration.
   1121            */
   1122          ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, I2C_IT_TypeDef I2C_IT)
   1123          {
   1124            ITStatus bitstatus = RESET;
   1125            __IO uint8_t enablestatus = 0;
   1126            uint16_t tempregister = 0;
   1127          
   1128            /* Check the parameters */
   1129            assert_param(IS_I2C_GET_IT(I2C_IT));
   1130          
   1131            tempregister = (uint8_t)( ((uint16_t)((uint16_t)I2C_IT & ITEN_Mask)) >> 8);
   1132          
   1133            /* Check if the interrupt source is enabled or not */
   1134            enablestatus = (uint8_t)(I2Cx->ITR & ( uint8_t)tempregister);
   1135          
   1136            if ((uint16_t)((uint16_t)I2C_IT & REGISTER_Mask) == REGISTER_SR1_Index)
   1137            {
   1138              /* Check the status of the specified I2C flag */
   1139              if (((I2Cx->SR1 & (uint8_t)I2C_IT) != RESET) && enablestatus)
   1140              {
   1141                /* I2C_IT is set */
   1142                bitstatus = SET;
   1143              }
   1144              else
   1145              {
   1146                /* I2C_IT is reset */
   1147                bitstatus = RESET;
   1148              }
   1149            }
   1150            else
   1151            {
   1152              /* Check the status of the specified I2C flag */
   1153              if (((I2Cx->SR2 & (uint8_t)I2C_IT) != RESET) && enablestatus)
   1154              {
   1155                /* I2C_IT is set */
   1156                bitstatus = SET;
   1157              }
   1158              else
   1159              {
   1160                /* I2C_IT is reset */
   1161                bitstatus = RESET;
   1162              }
   1163            }
   1164            /* Return the I2C_IT status */
   1165            return  bitstatus;
   1166          }
   1167          /**
   1168            * @brief  Clear IT pending bit
   1169            * @param  I2Cx : where x can be 1 to select the specified I2C peripheral.
   1170            * @param  I2C_IT: specifies the interrupt pending bit to clear.
   1171            *            This parameter can be any combination of the following values:
   1172            *                 - I2C_IT_SMBALERT: SMBus Alert interrupt
   1173            *                 - I2C_IT_TIMEOUT: Timeout or Tlow error interrupt
   1174            *                 - I2C_IT_PECERR: PEC error in reception  interrupt
   1175            *                 - I2C_IT_WUFH: Wakeup from Halt
   1176            *                 - I2C_IT_OVR: Overrun/Underrun interrupt (Slave mode)
   1177            *                 - I2C_IT_AF: Acknowledge failure interrupt
   1178            *                 - I2C_IT_ARLO: Arbitration lost interrupt (Master mode)
   1179            *                 - I2C_IT_BERR: Bus error interrupt
   1180            *
   1181            *             Notes:
   1182            *                  - STOPF (STOP detection) is cleared by software
   1183            *                    sequence: a read operation to I2C_SR1 register
   1184            *                    (I2C_GetITStatus()) followed by a write operation to
   1185            *                    I2C_CR2 register (I2C_AcknowledgeConfig() to configure
   1186            *                    the I2C peripheral Acknowledge).
   1187            *                  - ADD10 (10-bit header sent) is cleared by software
   1188            *                    sequence: a read operation to I2C_SR1
   1189            *                    (I2C_GetITStatus()) followed by writing the second
   1190            *                    byte of the address in I2C_DR register.
   1191            *                  - BTF (Byte Transfer Finished) is cleared by software
   1192            *                    sequence: a read operation to I2C_SR1 register
   1193            *                    (I2C_GetITStatus()) followed by a read/write to
   1194            *                    I2C_DR register (I2C_SendData()).
   1195            *                  - ADDR (Address sent) is cleared by software sequence:
   1196            *                    a read operation to I2C_SR1 register (I2C_GetITStatus())
   1197            *                    followed by a read operation to I2C_SR3 register
   1198            *                    ((void)(I2Cx->SR3)).
   1199            *                  - SB (Start Bit) is cleared by software sequence: a
   1200            *                    read operation to I2C_SR1 register (I2C_GetITStatus())
   1201            *                    followed by a write operation to I2C_DR reigister
   1202            *                    (I2C_SendData()).
   1203            * @retval None
   1204            */
   1205          void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, I2C_IT_TypeDef I2C_IT)
   1206          {
   1207            uint16_t flagpos = 0;
   1208          
   1209            /* Check the parameters */
   1210            assert_param(IS_I2C_CLEAR_IT(I2C_IT));
   1211          
   1212            /* Get the I2C flag position */
   1213            flagpos = (uint16_t)I2C_IT & FLAG_Mask;
   1214          
   1215            /* Clear the selected I2C flag */
   1216            I2Cx->SR2 = (uint8_t)((uint16_t)~flagpos);
   1217          }
   1218          /**
   1219            * @}
   1220            */
   1221          
   1222          /**
   1223            * @}
   1224            */
   1225          
   1226          /******************* (C) COPYRIGHT 2010 STMicroelectronics *****END OF FILE****/

   Section sizes:

   Bytes  Function/Label
   -----  --------------
      13  I2C_ARPCmd
      27  I2C_AckPositionConfig
      25  I2C_AcknowledgeConfig
      13  I2C_CalculatePEC
     104  I2C_CheckEvent
      24  I2C_ClearFlag
      24  I2C_ClearITPendingBit
      13  I2C_Cmd
      33  I2C_DMACmd
      33  I2C_DMALastTransferCmd
      79  I2C_DeInit
      33  I2C_DualAddressCmd
      34  I2C_FastModeDutyCycleConfig
      13  I2C_GeneralCallCmd
      25  I2C_GenerateSTART
      25  I2C_GenerateSTOP
      74  I2C_GetFlagStatus
      64  I2C_GetITStatus
      76  I2C_GetLastEvent
       5  I2C_GetPEC
      41  I2C_ITConfig
     480  I2C_Init
      35  I2C_OwnAddress2Config
      27  I2C_PECPositionConfig
      21  I2C_ReadRegister
       5  I2C_ReceiveData
      25  I2C_SMBusAlertConfig
      15  I2C_Send7bitAddress
       5  I2C_SendData
      25  I2C_SoftwareResetCmd
      13  I2C_StretchClockCmd
      25  I2C_TransmitPEC

 
 1 454 bytes in section .far_func.text
 
 1 454 bytes of CODE memory

Errors: none
Warnings: none
