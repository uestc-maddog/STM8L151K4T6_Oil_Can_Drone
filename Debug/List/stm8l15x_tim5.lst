###############################################################################
#
# IAR C/C++ Compiler V2.10.4.157 for STM8                 10/Jan/2017  20:04:40
# Copyright 2010-2015 IAR Systems AB.
#
#    Source file  =  
#        E:\Github
#        Project\STM8L151K4T6_Oil_Can_Drone\STM8L15x_StdPeriph_Driver\src\stm8l15x_tim5.c
#    Command line =  
#        "E:\Github
#        Project\STM8L151K4T6_Oil_Can_Drone\STM8L15x_StdPeriph_Driver\src\stm8l15x_tim5.c"
#        -e -Ol --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_cross_call --debug --code_model medium --data_model medium -o
#        "E:\Github Project\STM8L151K4T6_Oil_Can_Drone\Debug\Obj\"
#        --dlib_config "E:\My Program\IAR_STM8-7.0\stm8\LIB\dlstm8mmf.h" -D
#        STM8L15X_MD -lcN "E:\Github
#        Project\STM8L151K4T6_Oil_Can_Drone\Debug\List\" -I "E:\Github
#        Project\STM8L151K4T6_Oil_Can_Drone\" -I "E:\Github
#        Project\STM8L151K4T6_Oil_Can_Drone\STM8L15x_StdPeriph_Driver\inc\" -I
#        "E:\Github Project\STM8L151K4T6_Oil_Can_Drone\APP\" -I "E:\Github
#        Project\STM8L151K4T6_Oil_Can_Drone\BSP\" --vregs 16
#    List file    =  
#        E:\Github
#        Project\STM8L151K4T6_Oil_Can_Drone\Debug\List\stm8l15x_tim5.lst
#    Object file  =  
#        E:\Github Project\STM8L151K4T6_Oil_Can_Drone\Debug\Obj\stm8l15x_tim5.o
#
###############################################################################

E:\Github Project\STM8L151K4T6_Oil_Can_Drone\STM8L15x_StdPeriph_Driver\src\stm8l15x_tim5.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm8l15x_TIM5.c
      4            * @author  MCD Application Team
      5            * @version V1.4.0
      6            * @date    09/24/2010
      7            * @brief   This file provides all the TIM5 firmware functions.
      8            ******************************************************************************
      9            * @copy
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2010 STMicroelectronics</center></h2>
     19            */
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "stm8l15x_TIM5.h"
     23          
     24          /** @addtogroup STM8L15x_StdPeriph_Driver
     25            * @{
     26            */
     27          
     28          /* Private typedef -----------------------------------------------------------*/
     29          /* Private define ------------------------------------------------------------*/
     30          /* Private macro -------------------------------------------------------------*/
     31          /* Private variables ---------------------------------------------------------*/
     32          /* Private function prototypes -----------------------------------------------*/
     33          static void TI1_Config(TIM5_ICPolarity_TypeDef TIM5_ICPolarity,
     34                                 TIM5_ICSelection_TypeDef TIM5_ICSelection,
     35                                 uint8_t TIM5_ICFilter);
     36          static void TI2_Config(TIM5_ICPolarity_TypeDef TIM5_ICPolarity,
     37                                 TIM5_ICSelection_TypeDef TIM5_ICSelection,
     38                                 uint8_t TIM5_ICFilter);
     39          
     40          
     41          /**
     42            * @addtogroup TIM5_Public_Functions
     43            * @{
     44            */
     45          
     46          /**
     47            * @brief  Deinitializes the TIM5 peripheral registers to their default reset values.
     48            * @param  None
     49            * @retval None
     50            */
     51          void TIM5_DeInit(void)
     52          {
     53            TIM5->CR1 = TIM_CR1_RESET_VALUE;
     54            TIM5->CR2 = TIM_CR2_RESET_VALUE;
     55            TIM5->SMCR = TIM_SMCR_RESET_VALUE;
     56            TIM5->ETR = TIM_ETR_RESET_VALUE;
     57            TIM5->IER = TIM_IER_RESET_VALUE;
     58            TIM5->SR2 = TIM_SR2_RESET_VALUE;
     59          
     60            /* Disable channels */
     61            TIM5->CCER1 = TIM_CCER1_RESET_VALUE;
     62            /* Configure channels as inputs: it is necessary if lock level is equal to 2 or 3 */
     63            TIM5->CCMR1 = 0x01;/*TIM5_ICxSource_TIxFPx */
     64            TIM5->CCMR2 = 0x01;/*TIM5_ICxSource_TIxFPx */
     65          
     66            /* Then reset channel registers: it also works if lock level is equal to 2 or 3 */
     67            TIM5->CCER1 = TIM_CCER1_RESET_VALUE;
     68            TIM5->CCMR1 = TIM_CCMR1_RESET_VALUE;
     69            TIM5->CCMR2 = TIM_CCMR2_RESET_VALUE;
     70          
     71            TIM5->CNTRH = TIM_CNTRH_RESET_VALUE;
     72            TIM5->CNTRL = TIM_CNTRL_RESET_VALUE;
     73          
     74            TIM5->PSCR = TIM_PSCR_RESET_VALUE;
     75          
     76            TIM5->ARRH = TIM_ARRH_RESET_VALUE;
     77            TIM5->ARRL = TIM_ARRL_RESET_VALUE;
     78          
     79            TIM5->CCR1H = TIM_CCR1H_RESET_VALUE;
     80            TIM5->CCR1L = TIM_CCR1L_RESET_VALUE;
     81            TIM5->CCR2H = TIM_CCR2H_RESET_VALUE;
     82            TIM5->CCR2L = TIM_CCR2L_RESET_VALUE;
     83          
     84          
     85            TIM5->OISR = TIM_OISR_RESET_VALUE;
     86            TIM5->EGR = 0x01;/* TIM_EGR_UG */
     87            TIM5->BKR = TIM_BKR_RESET_VALUE;
     88            TIM5->SR1 = TIM_SR1_RESET_VALUE;
     89          }
     90          
     91          /**
     92            * @brief  Initializes the TIM5 Time Base Unit according to the specified  parameters.
     93            * @param  TIM5_Prescaler : This parameter can be any member of the @Ref TIM5_Prescaler_TypeDef enumeration.
     94            * @param  TIM5_CounterMode : This parameter can be any member of the @Ref TIM5_CounterMode_TypeDef enumeration.
     95            * @param  TIM5_Period : This parameter must be a value between 0x0000 and 0xFFFF.
     96            * @retval None
     97            */
     98          
     99          void TIM5_TimeBaseInit(TIM5_Prescaler_TypeDef TIM5_Prescaler,
    100                                 TIM5_CounterMode_TypeDef TIM5_CounterMode,
    101                                 uint16_t TIM5_Period)
    102          {
    103          
    104            assert_param(IS_TIM5_PRESCALER(TIM5_Prescaler));
    105            assert_param(IS_TIM5_COUNTER_MODE(TIM5_CounterMode));
    106          
    107          
    108          
    109            /* Set the Autoreload value */
    110            TIM5->ARRH = (uint8_t)(TIM5_Period >> 8) ;
    111            TIM5->ARRL = (uint8_t)(TIM5_Period);
    112          
    113            /* Set the Prescaler value */
    114            TIM5->PSCR = (uint8_t)(TIM5_Prescaler);
    115          
    116            /* Select the Counter Mode */
    117            TIM5->CR1 &= (uint8_t)((uint8_t)(~TIM_CR1_CMS)) & ((uint8_t)(~TIM_CR1_DIR));
    118            TIM5->CR1 |= (uint8_t)(TIM5_CounterMode);
    119          
    120            /* Generate an update event to reload the Prescaler value immediately */
    121            TIM5->EGR = TIM5_EventSource_Update;
    122          }
    123          
    124          /**
    125            * @brief  Initializes the TIM5 Channel1 according to the specified parameters.
    126            * @param  TIM5_OCMode : This parameter can be any member of the @Ref TIM5_OCMode_TypeDef enumeration.
    127            * @param  TIM5_OutputState : This parameter can be any member of the @Ref TIM5_OutputState_TypeDef enumeration.
    128            * @param  TIM5_Pulse : This parameter must be a value between 0x0000 and 0xFFFF.
    129            * @param  TIM5_OCPolarity : This parameter can be any member of the @Ref TIM5_OCPolarity_TypeDef enumeration.
    130            * @param  TIM5_OCIdleState : This parameter can be any member of the @Ref TIM5_OCIdleState_TypeDef  enumeration.
    131            * @retval None
    132            */
    133          void TIM5_OC1Init(TIM5_OCMode_TypeDef TIM5_OCMode,
    134                            TIM5_OutputState_TypeDef TIM5_OutputState,
    135                            uint16_t TIM5_Pulse,
    136                            TIM5_OCPolarity_TypeDef TIM5_OCPolarity,
    137                            TIM5_OCIdleState_TypeDef TIM5_OCIdleState)
    138          {
    139            uint8_t tmpccmr1 = 0;
    140          
    141            /* Check the parameters */
    142            assert_param(IS_TIM5_OC_MODE(TIM5_OCMode));
    143            assert_param(IS_TIM5_OUTPUT_STATE(TIM5_OutputState));
    144            assert_param(IS_TIM5_OC_POLARITY(TIM5_OCPolarity));
    145            assert_param(IS_TIM5_OCIDLE_STATE(TIM5_OCIdleState));
    146          
    147            tmpccmr1 = TIM5->CCMR1;
    148          
    149            /* Disable the Channel 1: Reset the CCE Bit */
    150            TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC1E);
    151            /* Reset the Output Compare Bits */
    152            tmpccmr1 &= (uint8_t)(~TIM_CCMR_OCM);
    153          
    154            /* Set the Ouput Compare Mode */
    155            tmpccmr1 |= (uint8_t)TIM5_OCMode;
    156          
    157            TIM5->CCMR1 = tmpccmr1;
    158          
    159            /* Set the Output State */
    160            if (TIM5_OutputState == TIM5_OutputState_Enable)
    161            {
    162              TIM5->CCER1 |= TIM_CCER1_CC1E;
    163            }
    164            else
    165            {
    166              TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC1E);
    167            }
    168          
    169            /* Set the Output Polarity */
    170            if (TIM5_OCPolarity == TIM5_OCPolarity_Low)
    171            {
    172              TIM5->CCER1 |= TIM_CCER1_CC1P;
    173            }
    174            else
    175            {
    176              TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC1P);
    177            }
    178          
    179            /* Set the Output Idle state */
    180            if (TIM5_OCIdleState == TIM5_OCIdleState_Set)
    181            {
    182              TIM5->OISR |= TIM_OISR_OIS1;
    183            }
    184            else
    185            {
    186              TIM5->OISR &= (uint8_t)(~TIM_OISR_OIS1);
    187            }
    188          
    189            /* Set the Pulse value */
    190            TIM5->CCR1H = (uint8_t)(TIM5_Pulse >> 8);
    191            TIM5->CCR1L = (uint8_t)(TIM5_Pulse);
    192          }
    193          
    194          /**
    195            * @brief  Initializes the TIM5 Channel2 according to the specified parameters.
    196            * @param  TIM5_OCMode : This parameter can be any member of the @Ref TIM5_OCMode_TypeDef enumeration.
    197            * @param  TIM5_OutputState : This parameter can be any member of the @Ref TIM5_OutputState_TypeDef enumeration.
    198            * @param  TIM5_Pulse : This parameter must be a value between 0x0000 and 0xFFFF.
    199            * @param  TIM5_OCPolarity : This parameter can be any member of the @Ref TIM5_OCPolarity_TypeDef enumeration.
    200            * @param  TIM5_OCIdleState : This parameter can be any member of the @Ref TIM5_OCIdleState_TypeDef  enumeration.
    201            * @retval None
    202            */
    203          void TIM5_OC2Init(TIM5_OCMode_TypeDef TIM5_OCMode,
    204                            TIM5_OutputState_TypeDef TIM5_OutputState,
    205                            uint16_t TIM5_Pulse,
    206                            TIM5_OCPolarity_TypeDef TIM5_OCPolarity,
    207                            TIM5_OCIdleState_TypeDef TIM5_OCIdleState)
    208          {
    209            uint8_t tmpccmr2 = 0;
    210          
    211            /* Check the parameters */
    212            assert_param(IS_TIM5_OC_MODE(TIM5_OCMode));
    213            assert_param(IS_TIM5_OUTPUT_STATE(TIM5_OutputState));
    214            assert_param(IS_TIM5_OC_POLARITY(TIM5_OCPolarity));
    215            assert_param(IS_TIM5_OCIDLE_STATE(TIM5_OCIdleState));
    216          
    217            tmpccmr2 = TIM5->CCMR2;
    218          
    219            /* Disable the Channel 2: Reset the CCE Bit */
    220            TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC2E);
    221          
    222            /* Reset the Output Compare Bits */
    223            tmpccmr2 &= (uint8_t)(~TIM_CCMR_OCM);
    224          
    225            /* Set the Ouput Compare Mode */
    226            tmpccmr2 |= (uint8_t)TIM5_OCMode;
    227          
    228            TIM5->CCMR2 = tmpccmr2;
    229          
    230            /* Set the Output State */
    231            if (TIM5_OutputState == TIM5_OutputState_Enable)
    232            {
    233              TIM5->CCER1 |= TIM_CCER1_CC2E;
    234            }
    235            else
    236            {
    237              TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC2E);
    238            }
    239          
    240            /* Set the Output Polarity */
    241            if (TIM5_OCPolarity == TIM5_OCPolarity_Low)
    242            {
    243              TIM5->CCER1 |= TIM_CCER1_CC2P;
    244            }
    245            else
    246            {
    247              TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC2P);
    248            }
    249          
    250          
    251            /* Set the Output Idle state */
    252            if (TIM5_OCIdleState == TIM5_OCIdleState_Set)
    253            {
    254              TIM5->OISR |= TIM_OISR_OIS2;
    255            }
    256            else
    257            {
    258              TIM5->OISR &= (uint8_t)(~TIM_OISR_OIS2);
    259            }
    260          
    261            /* Set the Pulse value */
    262            TIM5->CCR2H = (uint8_t)(TIM5_Pulse >> 8);
    263            TIM5->CCR2L = (uint8_t)(TIM5_Pulse);
    264          }
    265          
    266          /**
    267            * @brief  Configures the Break feature, dead time, Lock level, the OSSI,
    268            * and the AOE(automatic output enable).
    269            * @param  TIM5_OSSIState : Off-State Selection for Idle mode states.
    270            *   This parameter can be any member of the @Ref TIM5_OSSIState_TypeDef enumeration.
    271            * @param  TIM5_LockLevel : Lock level.
    272            *   This parameter can be any member of the @Ref TIM5_LockLevel_TypeDef enumeration.
    273            * @param  TIM5_BreakState : Break Input enable/disable .
    274            *   This parameter can be any member of the @Ref TIM5_BreakState_TypeDef enumeration.
    275            * @param  TIM5_BreakPolarity : Break Polarity.
    276            *   This parameter can be any member of the @Ref TIM5_BreakPolarity_TypeDef enumeration.
    277            * @param  TIM5_AutomaticOutput : TIM5 AOE Bit Set/Reset .
    278            *   This parameter can be anymember  of the @Ref TIM5_AutomaticOutput_TypeDef enumeration.
    279            * @retval None
    280            */
    281          void TIM5_BKRConfig(TIM5_OSSIState_TypeDef TIM5_OSSIState,
    282                              TIM5_LockLevel_TypeDef TIM5_LockLevel,
    283                              TIM5_BreakState_TypeDef TIM5_BreakState,
    284                              TIM5_BreakPolarity_TypeDef TIM5_BreakPolarity,
    285                              TIM5_AutomaticOutput_TypeDef TIM5_AutomaticOutput)
    286          
    287          {
    288            /* Check the parameters */
    289            assert_param(IS_TIM5_OSSI_STATE(TIM5_OSSIState));
    290            assert_param(IS_TIM5_LOCK_LEVEL(TIM5_LockLevel));
    291            assert_param(IS_TIM5_BREAK_STATE(TIM5_BreakState));
    292            assert_param(IS_TIM5_BREAK_POLARITY(TIM5_BreakPolarity));
    293            assert_param(IS_TIM5_AUTOMATIC_OUTPUT_STATE(TIM5_AutomaticOutput));
    294          
    295          
    296          
    297            /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSI State,
    298            the dead time value and the Automatic Output Enable Bit */
    299            TIM5->BKR = (uint8_t)((uint8_t)((uint8_t)((uint8_t)((uint8_t)TIM5_OSSIState | (uint8_t)TIM5_LockLevel) | \
    300                                            (uint8_t)((uint8_t)TIM5_BreakState | (uint8_t)TIM5_BreakPolarity)) | \
    301                                            TIM5_AutomaticOutput));
    302          }
    303          
    304          /**
    305            * @brief  Initializes the TIM5 peripheral according to the specified parameters.
    306            * @param  TIM5_Channel : This parameter can be any member of the @Ref TIM5_Channel_TypeDef enumeration.
    307            * @param  TIM5_ICPolarity : This parameter can be any member of the @Ref TIM5_ICPolarity_TypeDef enumeration.
    308            * @param  TIM5_ICSelection : This parameter can be any member of the @Ref TIM5_ICSelection_TypeDef enumeration.
    309            * @param  TIM5_ICPrescaler : This parameter can be any member of the @Ref TIM5_ICPSC_TypeDef enumeration.
    310            * @param  TIM5_ICFilter : This parameter must be a value between 0x00 and 0x0F.
    311            * @retval None
    312            */
    313          void TIM5_ICInit(TIM5_Channel_TypeDef TIM5_Channel,
    314                           TIM5_ICPolarity_TypeDef TIM5_ICPolarity,
    315                           TIM5_ICSelection_TypeDef TIM5_ICSelection,
    316                           TIM5_ICPSC_TypeDef TIM5_ICPrescaler,
    317                           uint8_t TIM5_ICFilter)
    318          {
    319            /* Check the parameters */
    320            assert_param(IS_TIM5_CHANNEL(TIM5_Channel));
    321          
    322            if (TIM5_Channel == TIM5_Channel_1)
    323            {
    324              /* TI1 Configuration */
    325              TI1_Config(TIM5_ICPolarity, TIM5_ICSelection, TIM5_ICFilter);
    326          
    327              /* Set the Input Capture Prescaler value */
    328              TIM5_SetIC1Prescaler(TIM5_ICPrescaler);
    329            }
    330            else /* if (TIM5_Channel == TIM5_Channel_2) */
    331            {
    332              /* TI2 Configuration */
    333              TI2_Config(TIM5_ICPolarity, TIM5_ICSelection, TIM5_ICFilter);
    334          
    335              /* Set the Input Capture Prescaler value */
    336              TIM5_SetIC2Prescaler(TIM5_ICPrescaler);
    337            }
    338          }
    339          
    340          /**
    341            * @brief  Configures the TIM5 peripheral in PWM Input Mode according to the
    342            * specified parameters.
    343            * @param  TIM5_Channel : This parameter can be any member of the @Ref TIM5_Channel_TypeDef enumeration.
    344            * @param  TIM5_ICPolarity : This parameter can be any member of the @Ref TIM5_ICPolarity_TypeDef enumeration.
    345            * @param  TIM5_ICSelection : This parameter can be any member of the @Ref TIM5_ICSelection_TypeDef enumeration.
    346            * @param  TIM5_ICPrescaler : This parameter can be any member of the @Ref TIM5_ICPSC_TypeDef enumeration.
    347            * @param  TIM5_ICFilter : This parameter must be a value between 0x00 and 0x0F.
    348            * @retval None
    349            */
    350          void TIM5_PWMIConfig(TIM5_Channel_TypeDef TIM5_Channel,
    351                               TIM5_ICPolarity_TypeDef TIM5_ICPolarity,
    352                               TIM5_ICSelection_TypeDef TIM5_ICSelection,
    353                               TIM5_ICPSC_TypeDef TIM5_ICPrescaler,
    354                               uint8_t TIM5_ICFilter)
    355          {
    356            uint8_t icpolarity = TIM5_ICPolarity_Rising;
    357            uint8_t icselection = TIM5_ICSelection_DirectTI;
    358          
    359            /* Check the parameters */
    360            assert_param(IS_TIM5_CHANNEL(TIM5_Channel));
    361          
    362            /* Select the Opposite Input Polarity */
    363            if (TIM5_ICPolarity == TIM5_ICPolarity_Rising)
    364            {
    365              icpolarity = TIM5_ICPolarity_Falling;
    366            }
    367            else
    368            {
    369              icpolarity = TIM5_ICPolarity_Rising;
    370            }
    371          
    372            /* Select the Opposite Input */
    373            if (TIM5_ICSelection == TIM5_ICSelection_DirectTI)
    374            {
    375              icselection = TIM5_ICSelection_IndirectTI;
    376            }
    377            else
    378            {
    379              icselection = TIM5_ICSelection_DirectTI;
    380            }
    381          
    382            if (TIM5_Channel == TIM5_Channel_1)
    383            {
    384              /* TI1 Configuration */
    385              TI1_Config(TIM5_ICPolarity, TIM5_ICSelection,
    386                         TIM5_ICFilter);
    387          
    388              /* Set the Input Capture Prescaler value */
    389              TIM5_SetIC1Prescaler(TIM5_ICPrescaler);
    390          
    391              /* TI2 Configuration */
    392              TI2_Config((TIM5_ICPolarity_TypeDef)icpolarity, (TIM5_ICSelection_TypeDef)icselection, TIM5_ICFilter);
    393          
    394              /* Set the Input Capture Prescaler value */
    395              TIM5_SetIC2Prescaler(TIM5_ICPrescaler);
    396            }
    397            else
    398            {
    399              /* TI2 Configuration */
    400              TI2_Config(TIM5_ICPolarity, TIM5_ICSelection,
    401                         TIM5_ICFilter);
    402          
    403              /* Set the Input Capture Prescaler value */
    404              TIM5_SetIC2Prescaler(TIM5_ICPrescaler);
    405          
    406              /* TI1 Configuration */
    407              TI1_Config((TIM5_ICPolarity_TypeDef)icpolarity, (TIM5_ICSelection_TypeDef)icselection, TIM5_ICFilter);
    408          
    409              /* Set the Input Capture Prescaler value */
    410              TIM5_SetIC1Prescaler(TIM5_ICPrescaler);
    411            }
    412          }
    413          
    414          /**
    415            * @brief  Enables or disables the TIM5 peripheral.
    416            * @param  NewState : The new state of the TIM5 peripheral.
    417            *   This parameter can be any of the @ref FunctionalState enumeration.
    418            * @retval None
    419            */
    420          void TIM5_Cmd(FunctionalState NewState)
    421          {
    422            /* Check the parameters */
    423            assert_param(IS_FUNCTIONAL_STATE(NewState));
    424          
    425            /* set or Reset the CEN Bit */
    426            if (NewState != DISABLE)
    427            {
    428              TIM5->CR1 |= TIM_CR1_CEN;
    429            }
    430            else
    431            {
    432              TIM5->CR1 &= (uint8_t)(~TIM_CR1_CEN);
    433            }
    434          }
    435          
    436          /**
    437            * @brief  Enables or disables the TIM5 peripheral Main Outputs.
    438            * @param  NewState : The new state of the TIM5 peripheral.
    439            *   This parameter can be any of the @ref FunctionalState enumeration.
    440            * @retval None
    441            */
    442          void TIM5_CtrlPWMOutputs(FunctionalState NewState)
    443          {
    444            /* Check the parameters */
    445            assert_param(IS_FUNCTIONAL_STATE(NewState));
    446          
    447            /* Set or Reset the MOE Bit */
    448          
    449            if (NewState != DISABLE)
    450            {
    451              TIM5->BKR |= TIM_BKR_MOE ;
    452            }
    453            else
    454            {
    455              TIM5->BKR &= (uint8_t)(~TIM_BKR_MOE) ;
    456            }
    457          }
    458          
    459          /**
    460            * @brief  Enables or disables the specified TIM5 interrupts.
    461            * @param  TIM5_IT : Specifies the TIM5 interrupts sources to be enabled or disabled.
    462            *   This parameter can be any combination of the @ref TIM5_IT_TypeDef enumeration.
    463            * @param  NewState : The new state of the TIM5 peripheral.
    464            *   This parameter can be any of the @ref FunctionalState enumeration.
    465            * @retval None
    466            */
    467          void TIM5_ITConfig(TIM5_IT_TypeDef TIM5_IT, FunctionalState NewState)
    468          {
    469            /* Check the parameters */
    470            assert_param(IS_TIM5_IT(TIM5_IT));
    471            assert_param(IS_FUNCTIONAL_STATE(NewState));
    472          
    473            if (NewState != DISABLE)
    474            {
    475              /* Enable the Interrupt sources */
    476              TIM5->IER |= (uint8_t)TIM5_IT;
    477            }
    478            else
    479            {
    480              /* Disable the Interrupt sources */
    481              TIM5->IER &= (uint8_t)(~(uint8_t)TIM5_IT);
    482            }
    483          }
    484          
    485          /**
    486            * @brief  Enables or disables the TIM5 DMA Requests.
    487            * @param  TIM5_DMASources: specifies the DMA Request sources.
    488            *   This parameter can be any combination of  @ref TIM5_DMASource_TypeDef enumeration.
    489            * @param  NewState: new state of the DMA Request sources.
    490            *   This parameter can be: ENABLE or DISABLE.
    491            * @retval None
    492            */
    493          void TIM5_DMACmd( TIM5_DMASource_TypeDef TIM5_DMASource, FunctionalState NewState)
    494          {
    495            /* Check the parameters */
    496            assert_param(IS_FUNCTIONAL_STATE(NewState));
    497            assert_param(IS_TIM5_DMA_SOURCE(TIM5_DMASource));
    498          
    499            if (NewState != DISABLE)
    500            {
    501              /* Enable the DMA sources */
    502              TIM5->DER |= TIM5_DMASource;
    503            }
    504            else
    505            {
    506              /* Disable the DMA sources */
    507              TIM5->DER &= (uint8_t)(~TIM5_DMASource);
    508            }
    509          }
    510          
    511          /**
    512            * @brief  Enables the TIM5 internal Clock.
    513            * @par Parameters:
    514            * None
    515            * @retval None
    516            */
    517          void TIM5_InternalClockConfig(void)
    518          {
    519            /* Disable slave mode to clock the prescaler directly with the internal clock */
    520            TIM5->SMCR &=  (uint8_t)(~TIM_SMCR_SMS);
    521          }
    522          
    523          /**
    524            * @brief  Configures the TIM5 External clock Mode1.
    525            * @param  TIM5_ExtTRGPrescaler : Specifies the external Trigger Prescaler.
    526            *   This parameter can be one of @ref TIM5_ExtTRGPSC_TypeDef enumeration.
    527            * @param  TIM5_ExtTRGPolarity : Specifies the external Trigger Polarity.
    528            *   This parameter can be one of @ref TIM5_ExtTRGPolarity_TypeDef enumeration.
    529            * @param  ExtTRGFilter : Specifies the External Trigger Filter.
    530            *   This parameter must be a value between 0x00 and 0x0F
    531            * @retval None
    532            */
    533          void TIM5_ETRClockMode1Config(TIM5_ExtTRGPSC_TypeDef TIM5_ExtTRGPrescaler,
    534                                        TIM5_ExtTRGPolarity_TypeDef TIM5_ExtTRGPolarity,
    535                                        uint8_t ExtTRGFilter)
    536          {
    537            /* Configure the ETR Clock source */
    538            TIM5_ETRConfig(TIM5_ExtTRGPrescaler, TIM5_ExtTRGPolarity, ExtTRGFilter);
    539          
    540            /* Select the External clock mode1 */
    541            TIM5->SMCR &= (uint8_t)(~TIM_SMCR_SMS);
    542            TIM5->SMCR |= (uint8_t)(TIM5_SlaveMode_External1);
    543          
    544            /* Select the Trigger selection : ETRF */
    545            TIM5->SMCR &= (uint8_t)(~TIM_SMCR_TS);
    546            TIM5->SMCR |= (uint8_t)((TIM5_TRGSelection_TypeDef)TIM5_TRGSelection_ETRF);
    547          }
    548          
    549          /**
    550            * @brief  Configures the TIM5 External clock Mode2.
    551            * @param  TIM5_ExtTRGPrescaler : Specifies the external Trigger Prescaler.
    552            *   This parameter can be one of the @ref TIM5_ExtTRGPSC_TypeDef enumeration.
    553            * @param  TIM5_ExtTRGPolarity : Specifies the external Trigger Polarity.
    554            *   This parameter can be one of the @ref TIM5_ExtTRGPolarity_TypeDef enumeration.
    555            * @param  ExtTRGFilter : Specifies the External Trigger Filter.
    556            *   This parameter must be a value between 0x00 and 0x0F
    557            * @retval None
    558            */
    559          void TIM5_ETRClockMode2Config(TIM5_ExtTRGPSC_TypeDef TIM5_ExtTRGPrescaler,
    560                                        TIM5_ExtTRGPolarity_TypeDef TIM5_ExtTRGPolarity,
    561                                        uint8_t ExtTRGFilter)
    562          {
    563            /* Configure the ETR Clock source */
    564            TIM5_ETRConfig(TIM5_ExtTRGPrescaler, TIM5_ExtTRGPolarity, ExtTRGFilter);
    565          
    566            /* Enable the External clock mode2 */
    567            TIM5->ETR |= TIM_ETR_ECE ;
    568          }
    569          
    570          /**
    571            * @brief  Configures the TIM5 External Trigger.
    572            * @param  TIM5_ExtTRGPrescaler : Specifies the external Trigger Prescaler.
    573            *   This parameter can be one of the @ref TIM5_ExtTRGPSC_TypeDef enumeration.
    574            * @param  TIM5_ExtTRGPolarity : Specifies the external Trigger Polarity.
    575            *   This parameter can be one of the @ref TIM5_ExtTRGPolarity_TypeDef enumeration.
    576            * @param  ExtTRGFilter : Specifies the External Trigger Filter.
    577            *   This parameter must be a value between 0x00 and 0x0F
    578            * @retval None
    579            */
    580          void TIM5_ETRConfig(TIM5_ExtTRGPSC_TypeDef TIM5_ExtTRGPrescaler,
    581                              TIM5_ExtTRGPolarity_TypeDef TIM5_ExtTRGPolarity,
    582                              uint8_t ExtTRGFilter)
    583          {
    584            /* Check the parameters */
    585            assert_param(IS_TIM5_EXT_PRESCALER(TIM5_ExtTRGPrescaler));
    586            assert_param(IS_TIM5_EXT_POLARITY(TIM5_ExtTRGPolarity));
    587            assert_param(IS_TIM5_EXT_FILTER(ExtTRGFilter));
    588          
    589            /* Set the Prescaler, the Filter value and the Polarity */
    590            TIM5->ETR |= (uint8_t)((uint8_t)((uint8_t)TIM5_ExtTRGPrescaler | (uint8_t)TIM5_ExtTRGPolarity)
    591                                   | (uint8_t)ExtTRGFilter);
    592          }
    593          
    594          /**
    595            * @brief  Configures the TIM5 Trigger as External Clock.
    596            * @param  TIM5_TIxExternalCLKSource : Specifies Trigger source.
    597            *   This parameter can be one of the @ref TIM5_TIxExternalCLK1Source_TypeDef enumeration.
    598            * @param  TIM5_ICPolarity : Specifies the TIx Polarity.
    599            *   This parameter can be @ref TIM5_ICPolarity_TypeDef enumeration.
    600            * @param  ICFilter : Specifies the filter value.
    601            *   This parameter must be a value between 0x00 and 0x0F
    602            * @retval None
    603            */
    604          void TIM5_TIxExternalClockConfig(TIM5_TIxExternalCLK1Source_TypeDef TIM5_TIxExternalCLKSource,
    605                                           TIM5_ICPolarity_TypeDef TIM5_ICPolarity,
    606                                           uint8_t ICFilter)
    607          {
    608            /* Check the parameters */
    609            assert_param(IS_TIM5_TIXCLK_SOURCE(TIM5_TIxExternalCLKSource));
    610            assert_param(IS_TIM5_IC_POLARITY(TIM5_ICPolarity));
    611            assert_param(IS_TIM5_IC_FILTER(ICFilter));
    612          
    613            /* Configure the TIM5 Input Clock Source */
    614            if (TIM5_TIxExternalCLKSource == TIM5_TIxExternalCLK1Source_TI2)
    615            {
    616              TI2_Config(TIM5_ICPolarity, TIM5_ICSelection_DirectTI, ICFilter);
    617            }
    618            else
    619            {
    620              TI1_Config(TIM5_ICPolarity, TIM5_ICSelection_DirectTI, ICFilter);
    621            }
    622          
    623            /* Select the Trigger source */
    624            TIM5_SelectInputTrigger((TIM5_TRGSelection_TypeDef)TIM5_TIxExternalCLKSource);
    625          
    626            /* Select the External clock mode1 */
    627            TIM5->SMCR |= (uint8_t)(TIM5_SlaveMode_External1);
    628          }
    629          
    630          /**
    631            * @brief  Selects the TIM5 Input Trigger source.
    632            * @param  TIM5_InputTriggerSource : Specifies Input Trigger source.
    633            *   This parameter can be one of the @ref TIM5_TRGSelection_TypeDef enumeration.
    634            * @retval None
    635            */
    636          void TIM5_SelectInputTrigger(TIM5_TRGSelection_TypeDef TIM5_InputTriggerSource)
    637          {
    638            uint8_t tmpsmcr = 0;
    639          
    640            /* Check the parameters */
    641            assert_param(IS_TIM5_TRIGGER_SELECTION(TIM5_InputTriggerSource));
    642          
    643            tmpsmcr = TIM5->SMCR;
    644          
    645            /* Select the Tgigger Source */
    646            tmpsmcr &= (uint8_t)(~TIM_SMCR_TS);
    647            tmpsmcr |= (uint8_t)TIM5_InputTriggerSource;
    648          
    649            TIM5->SMCR = (uint8_t)tmpsmcr;
    650          }
    651          
    652          /**
    653            * @brief  Enables or Disables the TIM5 Update event.
    654            * @param  NewState : The new state of the TIM5 peripheral Preload register.
    655            *   This parameter can be any of the @ref FunctionalState enumeration.
    656            * @retval None
    657            */
    658          
    659          void TIM5_UpdateDisableConfig(FunctionalState NewState)
    660          {
    661            /* Check the parameters */
    662            assert_param(IS_FUNCTIONAL_STATE(NewState));
    663          
    664            /* Set or Reset the UDIS Bit */
    665            if (NewState != DISABLE)
    666            {
    667              TIM5->CR1 |= TIM_CR1_UDIS;
    668            }
    669            else
    670            {
    671              TIM5->CR1 &= (uint8_t)(~TIM_CR1_UDIS);
    672            }
    673          }
    674          
    675          /**
    676            * @brief  Selects the TIM5 Update Request Interrupt source.
    677            * @param  TIM5_UpdateSource : Specifies the Update source.
    678            *   This parameter can be one of the @ref TIM5_UpdateSource_TypeDef enumeration.
    679            * @retval None
    680            */
    681          void TIM5_UpdateRequestConfig(TIM5_UpdateSource_TypeDef TIM5_UpdateSource)
    682          {
    683            /* Check the parameters */
    684            assert_param(IS_TIM5_UPDATE_SOURCE(TIM5_UpdateSource));
    685          
    686            /* Set or Reset the URS Bit */
    687            if (TIM5_UpdateSource == TIM5_UpdateSource_Regular)
    688            {
    689              TIM5->CR1 |= TIM_CR1_URS ;
    690            }
    691            else
    692            {
    693              TIM5->CR1 &= (uint8_t)(~TIM_CR1_URS);
    694            }
    695          }
    696          
    697          /**
    698            * @brief  Enables or Disables the TIM’s Hall sensor interface.
    699            * @param  NewState : The new state of the TIM5 Hall sensor interface.
    700            *   This parameter can be any of the @ref FunctionalState enumeration.
    701            * @retval None
    702            */
    703          void TIM5_SelectHallSensor(FunctionalState NewState)
    704          {
    705            /* Check the parameters */
    706            assert_param(IS_FUNCTIONAL_STATE(NewState));
    707          
    708            /* Set or Reset the TI1S Bit */
    709            if (NewState != DISABLE)
    710            {
    711              TIM5->CR2 |= TIM_CR2_TI1S;
    712            }
    713            else
    714            {
    715              TIM5->CR2 &= (uint8_t)(~TIM_CR2_TI1S);
    716            }
    717          }
    718          
    719          /**
    720            * @brief  Selects the TIM’s One Pulse Mode.
    721            * @param  TIM5_OPMode : Specifies the OPM Mode to be used.
    722            *   This parameter can be one of the @ref TIM5_OPMode_TypeDef enumeration.
    723            * @retval None
    724            */
    725          void TIM5_SelectOnePulseMode(TIM5_OPMode_TypeDef TIM5_OPMode)
    726          {
    727            /* Check the parameters */
    728            assert_param(IS_TIM5_OPM_MODE(TIM5_OPMode));
    729          
    730            /* Set or Reset the OPM Bit */
    731            if (TIM5_OPMode == TIM5_OPMode_Single)
    732            {
    733              TIM5->CR1 |= TIM_CR1_OPM ;
    734            }
    735            else
    736            {
    737              TIM5->CR1 &= (uint8_t)(~TIM_CR1_OPM);
    738            }
    739          }
    740          
    741          /**
    742            * @brief  Selects the TIM5 Trigger Output Mode.
    743            * @param  TIM5_TRGOSource : Specifies the Trigger Output source.
    744            *   This parameter can be one of the @ref TIM5_TRGOSource_TypeDef enumeration.
    745            * @retval None
    746            */
    747          void TIM5_SelectOutputTrigger(TIM5_TRGOSource_TypeDef TIM5_TRGOSource)
    748          {
    749            uint8_t tmpcr2 = 0;
    750          
    751            /* Check the parameters */
    752            assert_param(IS_TIM5_TRGO_SOURCE(TIM5_TRGOSource));
    753          
    754            tmpcr2 = TIM5->CR2;
    755          
    756            /* Reset the MMS Bits */
    757            tmpcr2 &= (uint8_t)(~TIM_CR2_MMS);
    758          
    759            /* Select the TRGO source */
    760            tmpcr2 |=  (uint8_t)TIM5_TRGOSource;
    761          
    762            TIM5->CR2 = tmpcr2;
    763          }
    764          
    765          /**
    766            * @brief  Selects the TIM5 Slave Mode.
    767            * @param  TIM5_SlaveMode : Specifies the TIM5 Slave Mode.
    768            *   This parameter can be one of the @ref TIM5_SlaveMode_TypeDef enumeration.
    769            * @retval None
    770            */
    771          void TIM5_SelectSlaveMode(TIM5_SlaveMode_TypeDef TIM5_SlaveMode)
    772          {
    773            uint8_t tmpsmcr = 0;
    774          
    775            /* Check the parameters */
    776            assert_param(IS_TIM5_SLAVE_MODE(TIM5_SlaveMode));
    777          
    778            tmpsmcr = TIM5->SMCR;
    779          
    780            /* Reset the SMS Bits */
    781            tmpsmcr &= (uint8_t)(~TIM_SMCR_SMS);
    782          
    783            /* Select the Slave Mode */
    784            tmpsmcr |= (uint8_t)TIM5_SlaveMode;
    785          
    786            TIM5->SMCR = tmpsmcr;
    787          }
    788          
    789          /**
    790            * @brief  Sets or Resets the TIM5 Master/Slave Mode.
    791            * @param  NewState : The new state of the synchronization between TIM5 and its slaves (through TRGO).
    792            *   This parameter can be any of the @ref FunctionalState enumeration.
    793            * @retval None
    794            */
    795          void TIM5_SelectMasterSlaveMode(FunctionalState NewState)
    796          {
    797            /* Check the parameters */
    798            assert_param(IS_FUNCTIONAL_STATE(NewState));
    799          
    800            /* Set or Reset the MSM Bit */
    801            if (NewState != DISABLE)
    802            {
    803              TIM5->SMCR |= TIM_SMCR_MSM;
    804            }
    805            else
    806            {
    807              TIM5->SMCR &= (uint8_t)(~TIM_SMCR_MSM);
    808            }
    809          }
    810          
    811          /**
    812            * @brief  Configures the TIM5 Encoder Interface.
    813            * @param  TIM5_EncoderMode : Specifies the TIM5 Encoder Mode.
    814            *   This parameter can be one of the @ref TIM5_EncoderMode_TypeDef enumeration.
    815            * @param  TIM5_IC1Polarity : Specifies the IC1 Polarity.
    816            *   This parameter can be one of the @ref TIM5_ICPolarity_TypeDef enumeration.
    817            * @param  TIM5_IC2Polarity : Specifies the IC2 Polarity.
    818            *   This parameter can be one of the @ref TIM5_ICPolarity_TypeDef enumeration.
    819            * @retval None
    820            */
    821          void TIM5_EncoderInterfaceConfig(TIM5_EncoderMode_TypeDef TIM5_EncoderMode,
    822                                           TIM5_ICPolarity_TypeDef TIM5_IC1Polarity,
    823                                           TIM5_ICPolarity_TypeDef TIM5_IC2Polarity)
    824          {
    825            uint8_t tmpsmcr = 0;
    826            uint8_t tmpccmr1 = 0;
    827            uint8_t tmpccmr2 = 0;
    828          
    829            /* Check the parameters */
    830            assert_param(IS_TIM5_ENCODER_MODE(TIM5_EncoderMode));
    831            assert_param(IS_TIM5_IC_POLARITY(TIM5_IC1Polarity));
    832            assert_param(IS_TIM5_IC_POLARITY(TIM5_IC2Polarity));
    833          
    834            tmpsmcr = TIM5->SMCR;
    835            tmpccmr1 = TIM5->CCMR1;
    836            tmpccmr2 = TIM5->CCMR2;
    837          
    838            /* Set the encoder Mode */
    839            tmpsmcr &= (uint8_t)(TIM_SMCR_MSM | TIM_SMCR_TS)  ;
    840            tmpsmcr |= (uint8_t)TIM5_EncoderMode;
    841          
    842            /* Select the Capture Compare 1 and the Capture Compare 2 as input */
    843            tmpccmr1 &= (uint8_t)(~TIM_CCMR_CCxS);
    844            tmpccmr2 &= (uint8_t)(~TIM_CCMR_CCxS);
    845            tmpccmr1 |= TIM_CCMR_TIxDirect_Set;
    846            tmpccmr2 |= TIM_CCMR_TIxDirect_Set;
    847          
    848            /* Set the TI1 and the TI2 Polarities */
    849            if (TIM5_IC1Polarity == TIM5_ICPolarity_Falling)
    850            {
    851              TIM5->CCER1 |= TIM_CCER1_CC1P ;
    852            }
    853            else
    854            {
    855              TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC1P) ;
    856            }
    857          
    858            if (TIM5_IC2Polarity == TIM5_ICPolarity_Falling)
    859            {
    860              TIM5->CCER1 |= TIM_CCER1_CC2P ;
    861            }
    862            else
    863            {
    864              TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC2P) ;
    865            }
    866          
    867            TIM5->SMCR = tmpsmcr;
    868            TIM5->CCMR1 = tmpccmr1;
    869            TIM5->CCMR2 = tmpccmr2;
    870          }
    871          
    872          /**
    873            * @brief  Configures the TIM5 Prescaler.
    874            * @param  Prescaler : Specifies the Prescaler Register value
    875            *   This parameter can be one of the @ref TIM5_Prescaler_TypeDef enumeration.
    876            * @param  TIM5_PSCReloadMode : Specifies the TIM5 Prescaler Reload mode.
    877            *   This parameter can be one of the @ref TIM5_PSCReloadMode_TypeDef enumeration.
    878            * @retval None
    879            */
    880          void TIM5_PrescalerConfig(TIM5_Prescaler_TypeDef Prescaler,
    881                                    TIM5_PSCReloadMode_TypeDef TIM5_PSCReloadMode)
    882          {
    883            /* Check the parameters */
    884            assert_param(IS_TIM5_PRESCALER(Prescaler));
    885            assert_param(IS_TIM5_PRESCALER_RELOAD(TIM5_PSCReloadMode));
    886          
    887            /* Set the Prescaler value */
    888            TIM5->PSCR = (uint8_t)(Prescaler);
    889          
    890            /* Set or reset the UG Bit */
    891            if (TIM5_PSCReloadMode == TIM5_PSCReloadMode_Immediate)
    892            {
    893              TIM5->EGR |= TIM_EGR_UG ;
    894            }
    895            else
    896            {
    897              TIM5->EGR &= (uint8_t)(~TIM_EGR_UG) ;
    898            }
    899          }
    900          
    901          /**
    902            * @brief  Specifies the TIM5 Counter Mode to be used.
    903            * @param  TIM5_CounterMode : Specifies the Counter Mode to be used
    904            *   This parameter can be one of the @ref TIM5_CounterMode_TypeDef enumeration.
    905            * @retval None
    906            */
    907          void TIM5_CounterModeConfig(TIM5_CounterMode_TypeDef TIM5_CounterMode)
    908          {
    909            uint8_t tmpcr1 = 0;
    910          
    911            /* Check the parameters */
    912            assert_param(IS_TIM5_COUNTER_MODE(TIM5_CounterMode));
    913          
    914            tmpcr1 = TIM5->CR1;
    915          
    916            /* Reset the CMS and DIR Bits */
    917            tmpcr1 &= (uint8_t)((uint8_t)(~TIM_CR1_CMS) & (uint8_t)(~TIM_CR1_DIR));
    918          
    919            /* Set the Counter Mode */
    920            tmpcr1 |= (uint8_t)TIM5_CounterMode;
    921          
    922            TIM5->CR1 = tmpcr1;
    923          }
    924          
    925          /**
    926            * @brief  Forces the TIM5 Channel1 output waveform to active or inactive level.
    927            * @param  TIM5_ForcedAction : Specifies the forced Action to be set to the output waveform.
    928            *   This parameter can be one of the @ref TIM5_ForcedAction_TypeDef enumeration.
    929            * @retval None
    930            */
    931          void TIM5_ForcedOC1Config(TIM5_ForcedAction_TypeDef TIM5_ForcedAction)
    932          {
    933            uint8_t tmpccmr1 = 0;
    934          
    935            /* Check the parameters */
    936            assert_param(IS_TIM5_FORCED_ACTION(TIM5_ForcedAction));
    937          
    938            tmpccmr1 = TIM5->CCMR1;
    939          
    940            /* Reset the OCM Bits */
    941            tmpccmr1 &= (uint8_t)(~TIM_CCMR_OCM);
    942          
    943            /* Configure The Forced output Mode */
    944            tmpccmr1 |= (uint8_t)TIM5_ForcedAction;
    945          
    946            TIM5->CCMR1 = tmpccmr1;
    947          }
    948          
    949          /**
    950            * @brief  Forces the TIM5 Channel2 output waveform to active or inactive level.
    951            * @param  TIM5_ForcedAction : Specifies the forced Action to be set to the output waveform.
    952            *   This parameter can be one of the @ref TIM5_ForcedAction_TypeDef enumeration.
    953            * @retval None
    954            */
    955          void TIM5_ForcedOC2Config(TIM5_ForcedAction_TypeDef TIM5_ForcedAction)
    956          {
    957            uint8_t tmpccmr2 = 0;
    958          
    959            /* Check the parameters */
    960            assert_param(IS_TIM5_FORCED_ACTION(TIM5_ForcedAction));
    961          
    962            tmpccmr2 = TIM5->CCMR2;
    963          
    964            /* Reset the OCM Bits */
    965            tmpccmr2 &= (uint8_t)(~TIM_CCMR_OCM);
    966          
    967            /* Configure The Forced output Mode */
    968            tmpccmr2 |= (uint8_t)TIM5_ForcedAction;
    969          
    970            TIM5->CCMR2 = tmpccmr2;
    971          }
    972          
    973          /**
    974            * @brief  Enables or disables TIM5 peripheral Preload register on ARR.
    975            * @param  NewState : The new state of the TIM5 peripheral Preload register.
    976            *   This parameter can be any of the @ref FunctionalState enumeration.
    977            * @retval None
    978            */
    979          void TIM5_ARRPreloadConfig(FunctionalState NewState)
    980          {
    981            /* Check the parameters */
    982            assert_param(IS_FUNCTIONAL_STATE(NewState));
    983          
    984            /* Set or Reset the ARPE Bit */
    985            if (NewState != DISABLE)
    986            {
    987              TIM5->CR1 |= TIM_CR1_ARPE;
    988            }
    989            else
    990            {
    991              TIM5->CR1 &= (uint8_t)(~TIM_CR1_ARPE);
    992            }
    993          }
    994          
    995          /**
    996            * @brief  Enables or disables the TIM5 peripheral Preload Register on CCR1.
    997            * @param  NewState : The new state of the Capture Compare Preload register.
    998            *   This parameter can be any of the @ref FunctionalState enumeration.
    999            * @retval None
   1000            */
   1001          void TIM5_OC1PreloadConfig(FunctionalState NewState)
   1002          {
   1003            /* Check the parameters */
   1004            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1005          
   1006            /* Set or Reset the OC1PE Bit */
   1007            if (NewState != DISABLE)
   1008            {
   1009              TIM5->CCMR1 |= TIM_CCMR_OCxPE ;
   1010            }
   1011            else
   1012            {
   1013              TIM5->CCMR1 &= (uint8_t)(~TIM_CCMR_OCxPE) ;
   1014            }
   1015          }
   1016          
   1017          /**
   1018            * @brief  Enables or disables the TIM5 peripheral Preload Register on CCR2.
   1019            * @param  NewState : The new state of the Capture Compare Preload register.
   1020            *   This parameter can be any of the @ref FunctionalState enumeration.
   1021            * @retval None
   1022            */
   1023          void TIM5_OC2PreloadConfig(FunctionalState NewState)
   1024          {
   1025            /* Check the parameters */
   1026            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1027          
   1028            /* Set or Reset the OC2PE Bit */
   1029            if (NewState != DISABLE)
   1030            {
   1031              TIM5->CCMR2 |= TIM_CCMR_OCxPE ;
   1032            }
   1033            else
   1034            {
   1035              TIM5->CCMR2 &= (uint8_t)(~TIM_CCMR_OCxPE) ;
   1036            }
   1037          }
   1038          
   1039          /**
   1040            * @brief  Configures the TIM5 Capture Compare 1 Fast feature.
   1041            * @param  NewState : The new state of the Output Compare Fast Enable bit.
   1042            *   This parameter can be any of the @ref FunctionalState enumeration.
   1043            * @retval None
   1044            */
   1045          void TIM5_OC1FastCmd(FunctionalState NewState)
   1046          {
   1047            /* Check the parameters */
   1048            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1049          
   1050            /* Set or Reset the OC1FE Bit */
   1051            if (NewState != DISABLE)
   1052            {
   1053              TIM5->CCMR1 |= TIM_CCMR_OCxFE ;
   1054            }
   1055            else
   1056            {
   1057              TIM5->CCMR1 &= (uint8_t)(~TIM_CCMR_OCxFE) ;
   1058            }
   1059          }
   1060          
   1061          /**
   1062            * @brief  Configures the TIM5 Capture Compare 2 Fast feature.
   1063            * @param  NewState : The new state of the Output Compare Fast Enable bit.
   1064            *   This parameter can be any of the @ref FunctionalState enumeration.
   1065            * @retval None
   1066            */
   1067          
   1068          void TIM5_OC2FastCmd(FunctionalState NewState)
   1069          {
   1070            /* Check the parameters */
   1071            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1072          
   1073            /* Set or Reset the OC2FE Bit */
   1074            if (NewState != DISABLE)
   1075            {
   1076              TIM5->CCMR2 |= TIM_CCMR_OCxFE ;
   1077            }
   1078            else
   1079            {
   1080              TIM5->CCMR2 &= (uint8_t)(~TIM_CCMR_OCxFE) ;
   1081            }
   1082          }
   1083          
   1084          /**
   1085            * @brief  Configures the TIM5 event to be generated by software.
   1086            * @param  TIM5_EventSource : Specifies the event source.
   1087            *   This parameter can be one of the @ref TIM5_EventSource_TypeDef enumeration.
   1088            * @retval None
   1089            */
   1090          void TIM5_GenerateEvent(TIM5_EventSource_TypeDef TIM5_EventSource)
   1091          {
   1092            /* Check the parameters */
   1093            assert_param(IS_TIM5_EVENT_SOURCE((uint8_t)TIM5_EventSource));
   1094          
   1095            /* Set the event sources */
   1096            TIM5->EGR |= (uint8_t)TIM5_EventSource;
   1097          }
   1098          
   1099          /**
   1100            * @brief  Configures the TIM5 Channel 1 polarity.
   1101            * @param  TIM5_OCPolarity : Specifies the OC1 Polarity.
   1102            *   This parameter can be one of the @ref TIM5_OCPolarity_TypeDef enumeration.
   1103            * @retval None
   1104            */
   1105          void TIM5_OC1PolarityConfig(TIM5_OCPolarity_TypeDef TIM5_OCPolarity)
   1106          {
   1107            /* Check the parameters */
   1108            assert_param(IS_TIM5_OC_POLARITY(TIM5_OCPolarity));
   1109          
   1110            /* Set or Reset the CC1P Bit */
   1111            if (TIM5_OCPolarity == TIM5_OCPolarity_Low)
   1112            {
   1113              TIM5->CCER1 |= TIM_CCER1_CC1P ;
   1114            }
   1115            else
   1116            {
   1117              TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC1P) ;
   1118            }
   1119          }
   1120          
   1121          /**
   1122            * @brief  Configures the TIM5 Channel 2 polarity.
   1123            * @param  TIM5_OCPolarity : Specifies the OC2 Polarity.
   1124            *   This parameter can be one of the @ref TIM5_OCPolarity_TypeDef enumeration.
   1125            * @retval None
   1126            */
   1127          void TIM5_OC2PolarityConfig(TIM5_OCPolarity_TypeDef TIM5_OCPolarity)
   1128          {
   1129            /* Check the parameters */
   1130            assert_param(IS_TIM5_OC_POLARITY(TIM5_OCPolarity));
   1131          
   1132            /* Set or Reset the CC2P Bit */
   1133            if (TIM5_OCPolarity == TIM5_OCPolarity_Low)
   1134            {
   1135              TIM5->CCER1 |= TIM_CCER1_CC2P ;
   1136            }
   1137            else
   1138            {
   1139              TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC2P) ;
   1140            }
   1141          }
   1142          
   1143          /**
   1144            * @brief  Enables or disables the TIM5 Capture Compare Channel x.
   1145            * @param  TIM5_Channel : Specifies the TIM5 Channel.
   1146            *   This parameter can be one of @ref TIM5_Channel_TypeDef enumeration.
   1147            * @param  NewState : Specifies the TIM5 Channel CCxE bit new state.
   1148            *   This parameter can be any of the @ref FunctionalState enumeration.
   1149            * @retval None
   1150            */
   1151          void TIM5_CCxCmd(TIM5_Channel_TypeDef TIM5_Channel,
   1152                           FunctionalState NewState)
   1153          {
   1154            /* Check the parameters */
   1155            assert_param(IS_TIM5_CHANNEL(TIM5_Channel));
   1156            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1157          
   1158            if (TIM5_Channel == TIM5_Channel_1)
   1159            {
   1160              /* Set or Reset the CC1E Bit */
   1161              if (NewState != DISABLE)
   1162              {
   1163                TIM5->CCER1 |= TIM_CCER1_CC1E ;
   1164              }
   1165              else
   1166              {
   1167                TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC1E) ;
   1168              }
   1169          
   1170            }
   1171            else /* if (TIM5_Channel == TIM5_Channel_2) */
   1172            {
   1173              /* Set or Reset the CC2E Bit */
   1174              if (NewState != DISABLE)
   1175              {
   1176                TIM5->CCER1 |= TIM_CCER1_CC2E;
   1177              }
   1178              else
   1179              {
   1180                TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC2E) ;
   1181              }
   1182            }
   1183          }
   1184          
   1185          /**
   1186            * @brief  Selects the TIM5 Ouput Compare Mode. This function disables the
   1187            * selected channel before changing the Ouput Compare Mode. User has to
   1188            * enable this channel using TIM5_CCxCmd and TIM5_CCxNCmd functions.
   1189            * @param  TIM5_Channel : Specifies the TIM5 Channel.
   1190            *   This parameter can be one of the @ref TIM5_Channel_TypeDef enumeration
   1191            * @param  TIM5_OCMode : Specifies the TIM5 Output Compare Mode.
   1192            *   This parameter can be one of the @ref TIM5_OCMode_TypeDef enumeration.
   1193            * @retval None
   1194            */
   1195          void TIM5_SelectOCxM(TIM5_Channel_TypeDef TIM5_Channel,
   1196                               TIM5_OCMode_TypeDef TIM5_OCMode)
   1197          {
   1198            /* Check the parameters */
   1199            assert_param(IS_TIM5_CHANNEL(TIM5_Channel));
   1200            assert_param(IS_TIM5_OCM(TIM5_OCMode));
   1201          
   1202            if (TIM5_Channel == TIM5_Channel_1)
   1203            {
   1204              /* Disable the Channel 1: Reset the CCE Bit */
   1205              TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC1E);
   1206          
   1207              /* Reset the Output Compare Bits */
   1208              TIM5->CCMR1 &= (uint8_t)(~TIM_CCMR_OCM);
   1209          
   1210              /* Set the Ouput Compare Mode */
   1211              TIM5->CCMR1 |= (uint8_t)TIM5_OCMode;
   1212            }
   1213            else /* if (TIM5_Channel == TIM5_Channel_2) */
   1214            {
   1215              /* Disable the Channel 2: Reset the CCE Bit */
   1216              TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC2E);
   1217          
   1218              /* Reset the Output Compare Bits */
   1219              TIM5->CCMR2 &= (uint8_t)(~TIM_CCMR_OCM);
   1220          
   1221              /* Set the Ouput Compare Mode */
   1222              TIM5->CCMR2 |= (uint8_t)TIM5_OCMode;
   1223            }
   1224          }
   1225          
   1226          /**
   1227            * @brief  Sets the TIM5 Counter Register value.
   1228            * @param  Counter : Specifies the Counter register new value.
   1229            *   This parameter is between 0x0000 and 0xFFFF.
   1230            * @retval None
   1231            */
   1232          void TIM5_SetCounter(uint16_t Counter)
   1233          {
   1234          
   1235            /* Set the Counter Register value */
   1236            TIM5->CNTRH = (uint8_t)(Counter >> 8);
   1237            TIM5->CNTRL = (uint8_t)(Counter);
   1238          }
   1239          
   1240          /**
   1241            * @brief  Sets the TIM5 Autoreload Register value.
   1242            * @param  Autoreload : Specifies the Autoreload register new value.
   1243            *   This parameter is between 0x0000 and 0xFFFF.
   1244            * @retval None
   1245            */
   1246          void TIM5_SetAutoreload(uint16_t Autoreload)
   1247          {
   1248            /* Set the Autoreload Register value */
   1249            TIM5->ARRH = (uint8_t)(Autoreload >> 8);
   1250            TIM5->ARRL = (uint8_t)(Autoreload);
   1251          }
   1252          
   1253          /**
   1254            * @brief  Sets the TIM5 Capture Compare1 Register value.
   1255            * @param  Compare : Specifies the Capture Compare1 register new value.
   1256            *   This parameter is between 0x0000 and 0xFFFF.
   1257            * @retval None
   1258            */
   1259          void TIM5_SetCompare1(uint16_t Compare)
   1260          {
   1261            /* Set the Capture Compare1 Register value */
   1262            TIM5->CCR1H = (uint8_t)(Compare >> 8);
   1263            TIM5->CCR1L = (uint8_t)(Compare);
   1264          }
   1265          
   1266          /**
   1267            * @brief  Sets the TIM5 Capture Compare2 Register value.
   1268            * @param  Compare : Specifies the Capture Compare2 register new value.
   1269            *   This parameter is between 0x0000 and 0xFFFF.
   1270            * @retval None
   1271            */
   1272          void TIM5_SetCompare2(uint16_t Compare)
   1273          {
   1274            /* Set the Capture Compare2 Register value */
   1275            TIM5->CCR2H = (uint8_t)(Compare >> 8);
   1276            TIM5->CCR2L = (uint8_t)(Compare);
   1277          }
   1278          
   1279          /**
   1280            * @brief  Sets the TIM5 Input Capture 1 prescaler.
   1281            * @param  TIM5_IC1Prescaler : Specifies the Input Capture prescaler new value
   1282            *   This parameter can be one of the @ref TIM5_ICPSC_TypeDef enumeration.
   1283            * @retval None
   1284            */
   1285          void TIM5_SetIC1Prescaler(TIM5_ICPSC_TypeDef TIM5_IC1Prescaler)
   1286          {
   1287            uint8_t tmpccmr1 = 0;
   1288          
   1289            /* Check the parameters */
   1290            assert_param(IS_TIM5_IC_PRESCALER(TIM5_IC1Prescaler));
   1291          
   1292            tmpccmr1 = TIM5->CCMR1;
   1293          
   1294            /* Reset the IC1PSC Bits */
   1295            tmpccmr1 &= (uint8_t)(~TIM_CCMR_ICxPSC);
   1296          
   1297            /* Set the IC1PSC value */
   1298            tmpccmr1 |= (uint8_t)TIM5_IC1Prescaler;
   1299          
   1300            TIM5->CCMR1 = tmpccmr1;
   1301          }
   1302          
   1303          /**
   1304            * @brief  Sets the TIM5 Input Capture 2 prescaler.
   1305            * @param  TIM5_IC2Prescaler : Specifies the Input Capture prescaler new value
   1306            *   This parameter can be one of the @ref TIM5_ICPSC_TypeDef enumeration.
   1307            * @retval None
   1308            */
   1309          void TIM5_SetIC2Prescaler(TIM5_ICPSC_TypeDef TIM5_IC2Prescaler)
   1310          {
   1311            uint8_t tmpccmr2 = 0;
   1312          
   1313            /* Check the parameters */
   1314            assert_param(IS_TIM5_IC_PRESCALER(TIM5_IC2Prescaler));
   1315          
   1316            tmpccmr2 = TIM5->CCMR2;
   1317          
   1318            /* Reset the IC2PSC Bits */
   1319            tmpccmr2 &= (uint8_t)(~TIM_CCMR_ICxPSC);
   1320          
   1321            /* Set the IC2PSC value */
   1322            tmpccmr2 |= (uint8_t)TIM5_IC2Prescaler;
   1323          
   1324            TIM5->CCMR2 = tmpccmr2;
   1325          }
   1326          
   1327          /**
   1328            * @brief  Gets the TIM5 Input Capture 1 value.
   1329            * @param  None
   1330            * @retval Capture Compare 1 Register value.
   1331            */
   1332          uint16_t TIM5_GetCapture1(void)
   1333          {
   1334            uint16_t tmpccr1 = 0;
   1335            uint8_t tmpccr1l, tmpccr1h;
   1336          
   1337            tmpccr1h = TIM5->CCR1H;
   1338            tmpccr1l = TIM5->CCR1L;
   1339          
   1340            tmpccr1 = (uint16_t)(tmpccr1l);
   1341            tmpccr1 |= (uint16_t)((uint16_t)tmpccr1h << 8);
   1342            /* Get the Capture 1 Register value */
   1343            return ((uint16_t)tmpccr1);
   1344          }
   1345          
   1346          /**
   1347            * @brief  Gets the TIM5 Input Capture 2 value.
   1348            * @param  None
   1349            * @retval Capture Compare 2 Register value.
   1350            */
   1351          uint16_t TIM5_GetCapture2(void)
   1352          {
   1353            uint16_t tmpccr2 = 0;
   1354            uint8_t tmpccr2l, tmpccr2h;
   1355          
   1356            tmpccr2h = TIM5->CCR2H;
   1357            tmpccr2l = TIM5->CCR2L;
   1358          
   1359            tmpccr2 = (uint16_t)(tmpccr2l);
   1360            tmpccr2 |= (uint16_t)((uint16_t)tmpccr2h << 8);
   1361            /* Get the Capture 2 Register value */
   1362            return ((uint16_t)tmpccr2);
   1363          }
   1364          
   1365          /**
   1366            * @brief  Gets the TIM5 Counter value.
   1367            * @param  None
   1368            * @retval Counter Register value.
   1369            */
   1370          uint16_t TIM5_GetCounter(void)
   1371          {
   1372            uint16_t tmpcnt = 0;
   1373            uint8_t tmpcntrl, tmpcntrh;
   1374          
   1375            tmpcntrh = TIM5->CNTRH;
   1376            tmpcntrl = TIM5->CNTRL;
   1377          
   1378            tmpcnt = (uint16_t)(tmpcntrl);
   1379            tmpcnt |= (uint16_t)((uint16_t)tmpcntrh << 8);
   1380            /* Get the Counter Register value */
   1381            return ((uint16_t)tmpcnt);
   1382          }
   1383          
   1384          /**
   1385            * @brief  Gets the TIM5 Prescaler value.
   1386            * @param  None
   1387            * @retval TIM5_Prescaler_TypeDef : Prescaler Register value.
   1388            */
   1389          TIM5_Prescaler_TypeDef TIM5_GetPrescaler(void)
   1390          {
   1391            /* Get the Prescaler Register value */
   1392            return ((TIM5_Prescaler_TypeDef)TIM5->PSCR);
   1393          }
   1394          
   1395          /**
   1396            * @brief  Selects the TIM5 peripheral Capture Compare DMA source.
   1397            * @param   NewState: new state of the Capture Compare DMA source.
   1398            *   This parameter can be: ENABLE or DISABLE.
   1399            * @retval None
   1400            */
   1401          void TIM5_SelectCCDMA(FunctionalState NewState)
   1402          {
   1403            /* Check the parameters */
   1404            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1405          
   1406            if (NewState != DISABLE)
   1407            {
   1408              /* Set the CCDS Bit */
   1409              TIM5->CR2 |= TIM_CR2_CCDS;
   1410            }
   1411            else
   1412            {
   1413              /* Reset the CCDS Bit */
   1414              TIM5->CR2 &= (uint8_t)(~TIM_CR2_CCDS);
   1415            }
   1416          }
   1417          
   1418          /**
   1419            * @brief  Checks whether the specified TIM5 flag is set or not.
   1420            * @param  TIM5_FLAG : Specifies the flag to check.
   1421            *   This parameter can be one of the @ref TIM5_FLAG_TypeDef enumeration.
   1422            * @retval FlagStatus : The new state of TIM5_FLAG.
   1423            *   This parameter can be any of the @ref FlagStatus enumeration.
   1424            */
   1425          FlagStatus TIM5_GetFlagStatus(TIM5_FLAG_TypeDef TIM5_FLAG)
   1426          {
   1427            FlagStatus bitstatus = RESET;
   1428            uint8_t tim5_flag_l = 0, tim5_flag_h = 0;
   1429          
   1430            /* Check the parameters */
   1431            assert_param(IS_TIM5_GET_FLAG(TIM5_FLAG));
   1432          
   1433            tim5_flag_l = (uint8_t)(TIM5->SR1 & (uint8_t)(TIM5_FLAG));
   1434            tim5_flag_h = (uint8_t)(TIM5->SR2 & (uint8_t)((uint16_t)TIM5_FLAG >> 8));
   1435          
   1436            if ((uint8_t)(tim5_flag_l | tim5_flag_h) != 0)
   1437            {
   1438              bitstatus = SET;
   1439            }
   1440            else
   1441            {
   1442              bitstatus = RESET;
   1443            }
   1444            return ((FlagStatus)bitstatus);
   1445          }
   1446          
   1447          /**
   1448            * @brief  Clears the TIM’s pending flags.
   1449            * @param  TIM5_FLAG : Specifies the flag to clear.
   1450            *   This parameter can be one of the @ref TIM5_FLAG_TypeDef enumeration.
   1451            * @retval None
   1452            */
   1453          void TIM5_ClearFlag(TIM5_FLAG_TypeDef TIM5_FLAG)
   1454          {
   1455            /* Check the parameters */
   1456            assert_param(IS_TIM5_CLEAR_FLAG((uint16_t)TIM5_FLAG));
   1457            /* Clear the flags (rc_w0) clear this bit by writing 0. Writing ‘1’ has no effect*/
   1458            TIM5->SR1 = (uint8_t)(~(uint8_t)(TIM5_FLAG));
   1459            TIM5->SR2 = (uint8_t)(~(uint8_t)((uint16_t)TIM5_FLAG >> 8));
   1460          }
   1461          
   1462          /**
   1463            * @brief  Checks whether the TIM5 interrupt has occurred or not.
   1464            * @param  TIM5_IT : Specifies the TIM5 interrupt source to check.
   1465            *   This parameter can be one of the @ref TIM5_IT_TypeDef enumeration.
   1466            * @retval ITStatus : The new state of the TIM5_IT.
   1467            *   This parameter can be any of the @ref ITStatus enumeration.
   1468            */
   1469          ITStatus TIM5_GetITStatus(TIM5_IT_TypeDef TIM5_IT)
   1470          {
   1471            ITStatus bitstatus = RESET;
   1472          
   1473            uint8_t TIM5_itStatus = 0x0, TIM5_itEnable = 0x0;
   1474          
   1475            /* Check the parameters */
   1476            assert_param(IS_TIM5_GET_IT(TIM5_IT));
   1477          
   1478            TIM5_itStatus = (uint8_t)(TIM5->SR1 & (uint8_t)TIM5_IT);
   1479          
   1480            TIM5_itEnable = (uint8_t)(TIM5->IER & (uint8_t)TIM5_IT);
   1481          
   1482            if ((TIM5_itStatus != (uint8_t)RESET ) && (TIM5_itEnable != (uint8_t)RESET))
   1483            {
   1484              bitstatus = (ITStatus)SET;
   1485            }
   1486            else
   1487            {
   1488              bitstatus = (ITStatus)RESET;
   1489            }
   1490            return ((ITStatus)bitstatus);
   1491          }
   1492          
   1493          /**
   1494            * @brief  Clears the TIM's interrupt pending bits.
   1495            * @param  TIM5_IT : Specifies the pending bit to clear.
   1496            *   This parameter can be one of the @ref TIM5_IT_TypeDef enumeration.
   1497            * @retval None
   1498            */
   1499          void TIM5_ClearITPendingBit(TIM5_IT_TypeDef TIM5_IT)
   1500          {
   1501            /* Check the parameters */
   1502            assert_param(IS_TIM5_IT(TIM5_IT));
   1503          
   1504            /* Clear the IT pending Bit */
   1505            TIM5->SR1 = (uint8_t)(~(uint8_t)TIM5_IT);
   1506          }
   1507          
   1508          /**
   1509            * @brief  Configure the TI1 as Input.
   1510            * @param  TIM5_ICPolarity : The Input Polarity.
   1511            *   This parameter can be one of the @ref TIM5_ICPolarity_TypeDef enumeration.
   1512            * @param  TIM5_ICSelection : Specifies the input to be used.
   1513            *   This parameter can be one of the @ref TIM5_ICSelection_TypeDef enumeration.
   1514            * @param  TIM5_ICFilter : Specifies the Input Capture Filter.
   1515            *   This parameter must be a value between 0x00 and 0x0F.
   1516            * @retval None
   1517            */
   1518          static void TI1_Config(TIM5_ICPolarity_TypeDef TIM5_ICPolarity, \
   1519                                 TIM5_ICSelection_TypeDef TIM5_ICSelection, \
   1520                                 uint8_t TIM5_ICFilter)
   1521          {
   1522            uint8_t tmpccmr1 = 0;
   1523            uint8_t tmpicpolarity = TIM5_ICPolarity;
   1524            tmpccmr1 = TIM5->CCMR1;
   1525          
   1526            /* Check the parameters */
   1527            assert_param(IS_TIM5_IC_POLARITY(TIM5_ICPolarity));
   1528            assert_param(IS_TIM5_IC_SELECTION(TIM5_ICSelection));
   1529            assert_param(IS_TIM5_IC_FILTER(TIM5_ICFilter));
   1530          
   1531            /* Disable the Channel 1: Reset the CCE Bit */
   1532            TIM5->CCER1 &=  (uint8_t)(~TIM_CCER1_CC1E);
   1533          
   1534            /* Select the Input and set the filter */
   1535            tmpccmr1 &= (uint8_t)(~TIM_CCMR_CCxS) & (uint8_t)(~TIM_CCMR_ICxF);
   1536            tmpccmr1 |= (uint8_t)(((uint8_t)(TIM5_ICSelection)) | ((uint8_t)(TIM5_ICFilter << 4)));
   1537          
   1538            TIM5->CCMR1 = tmpccmr1;
   1539          
   1540            /* Select the Polarity */
   1541            if (tmpicpolarity == (uint8_t)(TIM5_ICPolarity_Falling))
   1542            {
   1543              TIM5->CCER1 |= TIM_CCER1_CC1P;
   1544            }
   1545            else
   1546            {
   1547              TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC1P);
   1548            }
   1549          
   1550            /* Set the CCE Bit */
   1551            TIM5->CCER1 |=  TIM_CCER1_CC1E;
   1552          }
   1553          
   1554          /**
   1555            * @brief  Configure the TI2 as Input.
   1556            * @param  TIM5_ICPolarity : The Input Polarity.
   1557            *   This parameter can be one of the @ref TIM5_ICPolarity_TypeDef enumeration.
   1558            * @param  TIM5_ICSelection : Specifies the input to be used.
   1559            *   This parameter can be one of the @ref TIM5_ICSelection_TypeDef enumeration.
   1560            * @param  TIM5_ICFilter : Specifies the Input Capture Filter.
   1561            *   This parameter must be a value between 0x00 and 0x0F.
   1562            * @retval None
   1563            */
   1564          static void TI2_Config(TIM5_ICPolarity_TypeDef TIM5_ICPolarity,
   1565                                 TIM5_ICSelection_TypeDef TIM5_ICSelection,
   1566                                 uint8_t TIM5_ICFilter)
   1567          {
   1568            uint8_t tmpccmr2 = 0;
   1569            uint8_t tmpicpolarity = TIM5_ICPolarity;
   1570          
   1571            /* Check the parameters */
   1572            assert_param(IS_TIM5_IC_POLARITY(TIM5_ICPolarity));
   1573            assert_param(IS_TIM5_IC_SELECTION(TIM5_ICSelection));
   1574            assert_param(IS_TIM5_IC_FILTER(TIM5_ICFilter));
   1575          
   1576            tmpccmr2 = TIM5->CCMR2;
   1577          
   1578            /* Disable the Channel 2: Reset the CCE Bit */
   1579            TIM5->CCER1 &=  (uint8_t)(~TIM_CCER1_CC2E);
   1580          
   1581            /* Select the Input and set the filter */
   1582            tmpccmr2 &= (uint8_t)(~TIM_CCMR_CCxS) & (uint8_t)(~TIM_CCMR_ICxF);
   1583            tmpccmr2 |= (uint8_t)(((uint8_t)(TIM5_ICSelection)) | ((uint8_t)(TIM5_ICFilter << 4)));
   1584          
   1585            TIM5->CCMR2 = tmpccmr2;
   1586          
   1587            /* Select the Polarity */
   1588            if (tmpicpolarity == TIM5_ICPolarity_Falling)
   1589            {
   1590              TIM5->CCER1 |= TIM_CCER1_CC2P ;
   1591            }
   1592            else
   1593            {
   1594              TIM5->CCER1 &= (uint8_t)(~TIM_CCER1_CC2P) ;
   1595            }
   1596          
   1597            /* Set the CCE Bit */
   1598            TIM5->CCER1 |=  TIM_CCER1_CC2E;
   1599          }
   1600          /**
   1601            * @}
   1602            */
   1603          
   1604          /**
   1605            * @}
   1606            */
   1607          
   1608          /******************* (C) COPYRIGHT 2010 STMicroelectronics *****END OF FILE****/

   Section sizes:

   Bytes  Function/Label
   -----  --------------
      56  TI1_Config
      56  TI2_Config
      13  TIM5_ARRPreloadConfig
      22  TIM5_BKRConfig
      31  TIM5_CCxCmd
      13  TIM5_ClearFlag
       5  TIM5_ClearITPendingBit
      13  TIM5_Cmd
      27  TIM5_CounterModeConfig
      13  TIM5_CtrlPWMOutputs
      19  TIM5_DMACmd
     101  TIM5_DeInit
      37  TIM5_ETRClockMode1Config
       9  TIM5_ETRClockMode2Config
      15  TIM5_ETRConfig
     107  TIM5_EncoderInterfaceConfig
      27  TIM5_ForcedOC1Config
      27  TIM5_ForcedOC2Config
       7  TIM5_GenerateEvent
      34  TIM5_GetCapture1
      34  TIM5_GetCapture2
      34  TIM5_GetCounter
      39  TIM5_GetFlagStatus
      41  TIM5_GetITStatus
       4  TIM5_GetPrescaler
      39  TIM5_ICInit
      19  TIM5_ITConfig
       9  TIM5_InternalClockConfig
      13  TIM5_OC1FastCmd
      93  TIM5_OC1Init
      14  TIM5_OC1PolarityConfig
      13  TIM5_OC1PreloadConfig
      13  TIM5_OC2FastCmd
      93  TIM5_OC2Init
      14  TIM5_OC2PolarityConfig
      13  TIM5_OC2PreloadConfig
     131  TIM5_PWMIConfig
      19  TIM5_PrescalerConfig
      13  TIM5_SelectCCDMA
      13  TIM5_SelectHallSensor
      27  TIM5_SelectInputTrigger
      13  TIM5_SelectMasterSlaveMode
      45  TIM5_SelectOCxM
      14  TIM5_SelectOnePulseMode
      27  TIM5_SelectOutputTrigger
      27  TIM5_SelectSlaveMode
      15  TIM5_SetAutoreload
      15  TIM5_SetCompare1
      15  TIM5_SetCompare2
      15  TIM5_SetCounter
      27  TIM5_SetIC1Prescaler
      27  TIM5_SetIC2Prescaler
      48  TIM5_TIxExternalClockConfig
      42  TIM5_TimeBaseInit
      13  TIM5_UpdateDisableConfig
      14  TIM5_UpdateRequestConfig

 
 1 677 bytes in section .far_func.text
 
 1 677 bytes of CODE memory

Errors: none
Warnings: none
