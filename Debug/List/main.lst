###############################################################################
#
<<<<<<< HEAD
# IAR C/C++ Compiler V2.10.4.157 for STM8                 28/Dec/2016  15:25:47
=======
# IAR C/C++ Compiler V2.10.4.157 for STM8                 26/Dec/2016  10:48:18
>>>>>>> origin/master
# Copyright 2010-2015 IAR Systems AB.
#
#    Source file  =  
#        C:\Users\Growl\Desktop\STM8L151K4T6_Oil_Can_Drone+Uart_CSB\APP\main.c
#    Command line =  
#        C:\Users\Growl\Desktop\STM8L151K4T6_Oil_Can_Drone+Uart_CSB\APP\main.c
#        -e -Ol --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_cross_call --debug --code_model medium --data_model medium -o
#        C:\Users\Growl\Desktop\STM8L151K4T6_Oil_Can_Drone+Uart_CSB\Debug\Obj\
#        --dlib_config "E:\My Program\IAR_STM8-7.0\stm8\LIB\dlstm8mmf.h" -D
#        STM8L15X_MD -lcN
#        C:\Users\Growl\Desktop\STM8L151K4T6_Oil_Can_Drone+Uart_CSB\Debug\List\
#        -I C:\Users\Growl\Desktop\STM8L151K4T6_Oil_Can_Drone+Uart_CSB\ -I
#        C:\Users\Growl\Desktop\STM8L151K4T6_Oil_Can_Drone+Uart_CSB\STM8L15x_StdPeriph_Driver\inc\
#        -I C:\Users\Growl\Desktop\STM8L151K4T6_Oil_Can_Drone+Uart_CSB\APP\ -I
#        C:\Users\Growl\Desktop\STM8L151K4T6_Oil_Can_Drone+Uart_CSB\BSP\
#        --vregs 16
#    List file    =  
#        C:\Users\Growl\Desktop\STM8L151K4T6_Oil_Can_Drone+Uart_CSB\Debug\List\main.lst
#    Object file  =  
#        C:\Users\Growl\Desktop\STM8L151K4T6_Oil_Can_Drone+Uart_CSB\Debug\Obj\main.o
#
###############################################################################

C:\Users\Growl\Desktop\STM8L151K4T6_Oil_Can_Drone+Uart_CSB\APP\main.c
      1          #include "stdio.h" 
      2          #include "string.h" 
      3          #include "bsp.h" 
      4          #include "CC1101.h"
      5          
<<<<<<< HEAD
      6          // USART_CSB
      7          #define Dis_Len 2
      8          volatile u8 Distance[Dis_Len] = {0, 0};
      9          volatile u8 Dis_Index = 0;
     10          volatile u8 distance = 0; 
     11          
     12          // CC1101
     13          volatile u16  Cnt1ms = 0;     // 1ms计数变量，每1ms加一 
     14          int  RecvWaitTime = 0;        // 接收等待时间                
     15          u16  SendCnt = 0;             // 计数发送的数据包数                
     16          
     17                                     // 帧头  源地址  目标地址  distance*10  帧尾
     18          u8 SendBuffer[SEND_LENGTH] = {0x55,   0,    0xff,     15,          0xaa}; // 从机待发送数据
     19                                     // 帧头  源地址  目标地址  帧尾
     20          u8 AckBuffer[ACK_LENGTH]   = {0x55,  0xff,     0,     0xaa};        // 主机应答数据
     21                       
     22          void System_Initial(void);                     // 系统初始化
     23          u8   RF_SendPacket(u8 *Sendbuffer, u8 length);  // 从机发送数据包
     24          void Get_TheTime(void);
     25          void RTC_AWU_Initial(uint16_t time);            // time * 26.95 ms 
     26          void DelayMs(u16 x);                            // TIM3延时函数
     27          u8   Measured_Range(void);                      // 超声波测距
     28          
     29          // printf支持
     30          int putchar(int c)   
     31          {  
     32              while(!USART_GetFlagStatus(USART1, USART_FLAG_TXE));//等待发送完毕
     33              USART_SendData8(USART1, (uint8_t)c);
     34              return (c);  
     35          }
     36          
     37          void main(void)
     38          {
     39              volatile u8 res = 0;
     40              volatile u8 Timer_30s = 6;                        // 上电发送
     41              float ADC_Value = 0.0f;
     42                 
     43              System_Initial();                                 // 初始化系统所有外设               
     44              CC1101Init();                                     // 初始化CC1101为发送模式 
     45              SendBuffer[1] = TX_Address;                       // 数据包源地址（从机地址）
     46              
     47              while(1)
     48              {
     49                  printf("Timer_30s=%d\r\n", (int)Timer_30s);  
     50                  if(Timer_30s++ == 6)                   // 约 3 Min     30s * 6
     51                  {
     52                      SWITCH_ON();                       // 接通CC1101、CSB电源
     53                      LED_ON();                          // LED闪烁，用于指示发送成功
     54                      CSB_Initial();                     // 初始化超声波模块
     55                      CC1101Init();                      // 初始化CC1101模块
     56                      
     57                      distance = Measured_Range();       // 超声波测距 
     58                      if(distance)  
     59                      {
     60                          SendBuffer[3] = distance;
     61                          printf("distance = %d cm\r\n", distance);
     62                      }
     63                      else 
     64                      {
     65                          SendBuffer[3] = 0;             // 测量出错  发送0
     66                          printf("Measured_Error\r\n");
     67                      } 
     68          send:            
     69                      res = RF_SendPacket(SendBuffer, SEND_LENGTH);
     70                      if(res != 0) 
     71                      {
     72                          printf("Send ERROR:%d\r\n", (int)res);  // 发送失败
     73                          DelayMs(25);
     74                          goto send;
     75                      }
     76                      else printf("Send OK!\r\n");              // 发送成功
     77                      
     78                      SWITCH_OFF();
     79                      LED_OFF();
     80                      Timer_30s = 1;
     81                  }
     82                  RTC_AWU_Initial(1116);     // RTC 唤醒中断    1116 * 26.95 ms = 30s
     83                  halt();//挂起，最低功耗
     84              }
     85          }
     86          
     87          /*===========================================================================
     88          * 函数 : DelayMs() => 延时函数(ms级)                                        *
     89          * 输入 ：x, 需要延时多少(0-65535)                                             *
     90          ============================================================================*/
     91          void DelayMs(u16 x)
     92          {
     93              u16 timer_ms = x;
     94              
     95              Cnt1ms = 0;
     96              TIM3_Set(1);
     97              while(Cnt1ms < timer_ms);
     98              TIM3_Set(0);
     99          }
    100          
    101          /*===========================================================================
    102          * 函数 ：TIM3_1MS_ISR() => 定时器3服务函数, 定时时间基准为1ms               *
    103          ============================================================================*/
    104          void TIM3_1MS_ISR(void)
    105          {
    106              Cnt1ms++;
    107              if(RecvWaitTime > 0) RecvWaitTime--;    // 数据接收计时
    108          }
    109          
    110          /*===========================================================================
    111          * 函数: System_Initial() => 初始化系统所有外设                              *
    112          ============================================================================*/
    113          void System_Initial(void)
    114          {
    115              SClK_Initial();         // 初始化系统时钟，16M / 4 = 4M    
    116              GPIO_Initial();         // 初始化GPIO   LED  SWITCH
    117           
    118              CSB_Initial();          // 初始化超声波模块
    119              USART1_Initial();       // 初始化串口1  超声波模块使用 
    120              TIM3_Initial();         // 初始化定时器3，基准1ms  
    121              SPI_Initial();          // 初始化SPI  
    122              ADC_Initial();          // 初始化ADC
    123              
    124              //RTC_Initial();            // 初始化RTC   LSI
    125              //RTC_AWU_Initial(186);     // RTC 唤醒中断    186 * 26.95 ms = 5s
    126              enableInterrupts();     // 使能系统总中断
    127              
    128              printf("Oil_Can_Drone\r\n");                      // 发送字符串，末尾换行
    129          }
    130          
    131          /*===========================================================================
    132          * 函数 : BSP_RF_SendPacket() => 无线发送数据函数                            *
    133          * 输入 ：Sendbuffer指向待发送的数据，length发送数据长度                      *
    134          * 输出 ：0，发送成功                                                      
    135                   1，等待应答超时
    136                   2，数据包长度错误
    137                   3，数据包帧头错误
    138                   4，数据包源地址错误
    139                   5，数据包目标地址错误
    140                   6，数据包帧尾
    141                   7，应答信号错误
    142          ============================================================================*/
    143          INT8U RF_SendPacket(INT8U *Sendbuffer, INT8U length)
    144          {
    145              uint8_t  i = 0, ack_len = 0, ack_buffer[10] = {0};
    146              RecvWaitTime = (int)RECV_TIMEOUT;           // 等待应答超时限制1500ms
    147              
    148              CC1101SendPacket(SendBuffer, length, ADDRESS_CHECK);    // 发送数据 
    149              CC1101SetTRMode(RX_MODE);                               // 准备接收应答
    150          
    151              TIM3_Set(1);                                // 开启TIM3
    152              //printf("waiting for ack...\r\n");
    153              while(CC_IRQ_READ() != 0)                   // 等待接收数据包
    154              {
    155                  if(RecvWaitTime <= 0)      
    156                  {  
    157                      TIM3_Set(0);                            // 关闭TIM3
    158                      return 1;                              // 等待应答超时
    159                  }
    160              }
    161              RecvWaitTime = 50;           // 等待应答超时限制50ms
    162              while(CC_IRQ_READ() == 0)
    163              {
    164                  if(RecvWaitTime <= 0)      
    165                  {  
    166                      TIM3_Set(0);                            // 关闭TIM3
    167                      return 7;                              // 等待应答超时
    168                  }
    169              }
    170          //    printf("RecvWaitTime2=%d\r\n", RecvWaitTime);
    171              TIM3_Set(0);                                // 关闭TIM3
    172              ack_len = CC1101RecPacket(ack_buffer);      // 读取收到的数据
    173              
    174              if(ack_len <= 0 || ack_len > 10)  
    175              {
    176                  CC1101Init(); 
    177                  //printf("ack_len1=%d\r\n", ack_len);
    178                  return 2;                                          // 数据包长度错误
    179              }
    180              if(ack_len != ACK_LENGTH) return 2;                    // 数据包长度错误
    181              if(ack_buffer[0] != 0x55) return 3;                    // 数据包帧头错误
    182              if(ack_buffer[1] != 0xff) return 4;                    // 数据包源地址错误       
    183              if(ack_buffer[2] == 0xff) return 5;                    // 数据包目标地址错误
    184              if(ack_buffer[3] != 0xaa) return 6;            // 数据包帧尾
    185          
    186              // 应答正确
    187              printf("ack_len=%d;ack_buffer:", (int)ack_len);
    188              for(i = 0; i < ack_len; i++)                     
    189              {
    190                  printf("%d ", (int)ack_buffer[i]);
    191              }
    192              printf("\r\n");
    193          
    194              return 0;  
    195          }
    196          
    197          void Get_TheTime(void)
    198          {
    199            RTC_TimeTypeDef GETRTC_Time;
    200            RTC_DateTypeDef GETRTC_Data;
    201            //unsigned char sec_st,sec_su , min_mt,min_mu ,hour_ht , hour_hu , midd ,status;
    202            if(RTC_GetFlagStatus(RTC_FLAG_RSF) == SET)  //有时间更新 
    203            {
    204              
    205              
    206              RTC_GetDate(RTC_Format_BIN , &GETRTC_Data);
    207              RTC_GetTime(RTC_Format_BIN , &GETRTC_Time);  
    208                
    209               RTC_ClearFlag(RTC_FLAG_RSF);   //清除标志
    210               printf("20%d/%d/%d Day%d %d:%d:%d\r\n" , GETRTC_Data.RTC_Year , GETRTC_Data.RTC_Month  , GETRTC_Data.RTC_Date  ,  GETRTC_Data.RTC_WeekDay ,GETRTC_Time.RTC_Hours , GETRTC_Time.RTC_Minutes , GETRTC_Time.RTC_Seconds);
    211            }
    212          }
    213          
    214          void RTC_AWU_Initial(uint16_t time)    // time * 26.95 ms 
    215          { 
    216              RTC_DeInit(); //初始化默认状态 
    217              
    218              CLK_PeripheralClockConfig(CLK_Peripheral_RTC, ENABLE);      // 允许RTC时钟 
    219              CLK_RTCClockConfig(CLK_RTCCLKSource_LSI, CLK_RTCCLKDiv_64); // 选择RTC时钟源LSI/64=593.75Hz 
    220              RTC_WakeUpClockConfig(RTC_WakeUpClock_RTCCLK_Div16);        // 593.75Hz/16=37.109375Hz t = 26.95ms 
    221              RTC_ITConfig(RTC_IT_WUT, ENABLE);  // 开启中断 
    222              RTC_SetWakeUpCounter(time);        // 设置RTC Weakup计算器初值 
    223              RTC_WakeUpCmd(ENABLE);             // 使能自动唤醒 
    224          } 
    225          
    226          // 返回距离   0~255  cm
    227          // 0:测量出错
    228          u8 Measured_Range(void)
    229          {
    230              u8 distance_cm, error_timer = 0;
    231              
    232          Detectde:	
    233              distance_cm = 0;
    234              Distance[0] = 0;    // 清零，重新测距
    235              Distance[1] = 0;    
    236              Dis_Index = 0;
    237              CSB_Wakeup();
    238              DelayMs(1);       // 至少50us 唤醒
    239              
    240              DelayMs(4);       // 系统唤醒3ms后，发送测距触发信号0x55  
    241              
    242              //U1_Set(1);        // 开启U1接收中断，准备接收测量结果
    243              while(!USART_GetFlagStatus(USART1, USART_FLAG_TXE));//等待发送完毕
    244              USART_SendData8(USART1, 0x55); 
    245              
    246              DelayMs(25);      // 等待串口返回测量结果   25
    247              CSB_Sleep(); 
    248              //U1_Set(0);        // 关闭串口1
    249              
    250              if(Dis_Index == Dis_Len) // ok
    251              {
    252                  distance_cm = ( (( (u16)Distance[0] << 8 ) + Distance[1]) / 10 ) & 0xff;    // 限定distance_cm在[0, 255]范围内
    253                  return distance_cm;
    254              }
    255              else
    256              {
    257                  if(++error_timer == 10) return 0;     // 测距出错，返回0
    258                  goto Detectde;
    259              }
    260          }
    261          
    262          //    // CSB测试
    263          //    while(1)
    264          //    {
    265          //        distance = Measured_Range();    // 测距 
    266          //        if(distance)  
    267          //        {
    268          //            LED_ON();
    269          //            printf("distance = %d cm\r\n", distance);
    270          //        }
    271          //        else 
    272          //        {
    273          //            LED_OFF();
    274          //            printf("Measured_Error\r\n");
    275          //        } 
    276          //        
    277          //        DelayMs(1000); 
    278          //    }	
    279          //    // ADC+RTC测试 
    280          //    while(1)
    281          //    {
    282          //        ADC_Value = ADC_Data_Read();                  // PA6
    283          //        ADC_Value = ADC_Value / 0x0FFF * Voltage_Refer;
    284          //        printf("ADC_Value = %.2f V\r\n", ADC_Value);  
    285          //        Get_TheTime();
    286          //        DelayMs(1000);DelayMs(1000);
    287          //    }
    288              
    289          //    // RTC-AWU测试
    290          //    while(1)
    291          //    {
    292          //        LED_TOG();                // LED闪烁，用于指示发送成功
    293          //        printf("OK!\r\n");            
    294          //        RTC_AWU_Initial(186);     // RTC 唤醒中断    186 * 26.95 ms = 5s
    295          //        halt();//挂起，最低功耗
    296          //    }
    297              
    298          //    // 通信测试
    299          //    while(1)
    300          //    {
    301          //        LED_ON();                          // LED闪烁，用于指示发送成功
    302          // send:        
    303          //        res = RF_SendPacket(SendBuffer, SEND_LENGTH);
    304          //        if(res != 0) 
    305          //        {
    306          //          printf("Send ERROR:%d\r\nRetry now...\r\n", (int)res);  // 发送失败
    307          //          DelayMs(15);
    308          //          goto send;
    309          //        }
    310          //        else  printf("Send OK!\r\n");              // 发送成功
    311          //        LED_OFF();
    312          //        DelayMs(1000);DelayMs(1000);DelayMs(1000);DelayMs(1000);DelayMs(1000);
    313          //    }
=======
      6          volatile u16  Cnt1ms = 0;     // 1ms计数变量，每1ms加一 
      7          int  RecvWaitTime = 0;        // 接收等待时间                
      8          u16  SendCnt = 0;             // 计数发送的数据包数                
      9          
     10                                     // 帧头  源地址  目标地址  distance*10  帧尾
     11          u8 SendBuffer[SEND_LENGTH] = {0x55,   0,    0xff,     15,    0x0d, 0x0a}; // 从机待发送数据
     12                                     // 帧头  源地址  目标地址  帧尾
     13          u8 AckBuffer[ACK_LENGTH]   = {0x55,  0xff,     0,     0x0d, 0x0a};                                             // 主机应答数据
     14          
     15          void TIM3_Set(u8 sta);                          // 设置TIM3的开关   sta:0，关闭   1，开启                    
     16          void System_Initial(void);                     // 系统初始化
     17          u8   RF_SendPacket(u8 *Sendbuffer, u8 length);  // 从机发送数据包
     18          void Get_TheTime(void);
     19          void RTC_AWU_Initial(uint16_t time);            // time * 26.95 ms 
     20          void DelayMs(u16 x); 
     21          
     22          // printf支持
     23          int putchar(int c)   
     24          {  
     25            while(!USART_GetFlagStatus(USART1, USART_FLAG_TXE));//等待发送完毕
     26            USART_SendData8(USART1, (uint8_t)c);
     27            return (c);  
     28          }
     29          
     30          void Delay(__IO uint16_t nCount)
     31          {
     32              /* Decrement nCount value */
     33              while (nCount != 0)
     34              {
     35                  nCount--;
     36              }
     37          }
     38          
     39          void main(void)
     40          {
     41              volatile u8 res = 0;
     42              volatile u8 Timer_30s = 6;                        // 上电发送
     43              float ADC_Value = 0.0f;
     44                
     45              System_Initial();                                 // 初始化系统所有外设               
     46              //CC1101Init();                                     // 初始化CC1101为发送模式 
     47              SendBuffer[1] = TX_Address;                       // 数据包源地址（从机地址）
     48              
     49              
     50          //    // ADC+RTC测试 
     51          //    while(1)
     52          //    {
     53          //        ADC_Value = ADC_Data_Read();                  // PA6
     54          //        ADC_Value = ADC_Value / 0x0FFF * Voltage_Refer;
     55          //        printf("ADC_Value = %.2f V\r\n", ADC_Value);  
     56          //        Get_TheTime();
     57          //        DelayMs(1000);DelayMs(1000);
     58          //    }
     59              
     60          //    // RTC-AWU测试
     61          //    while(1)
     62          //    {
     63          //        LED_TOG();                // LED闪烁，用于指示发送成功
     64          //        printf("OK!\r\n");            
     65          //        RTC_AWU_Initial(186);     // RTC 唤醒中断    186 * 26.95 ms = 5s
     66          //        halt();//挂起，最低功耗
     67          //    }
     68              
     69          //    // 通信测试
     70          //    while(1)
     71          //    {
     72          //        LED_ON();                          // LED闪烁，用于指示发送成功
     73          // send:        
     74          //        res = RF_SendPacket(SendBuffer, SEND_LENGTH);
     75          //        if(res != 0) 
     76          //        {
     77          //          printf("Send ERROR:%d\r\nRetry now...\r\n", (int)res);  // 发送失败
     78          //          DelayMs(15);
     79          //          goto send;
     80          //        }
     81          //        else  printf("Send OK!\r\n");              // 发送成功
     82          //        LED_OFF();
     83          //        DelayMs(1000);DelayMs(1000);DelayMs(1000);DelayMs(1000);DelayMs(1000);
     84          //    }
     85              
     86              while(1)
     87              {
     88                  printf("Timer_30s=%d\r\n", (int)Timer_30s);  
     89                  if(Timer_30s++ == 6)                   // 约 3 Min     30s * 6
     90                  {
     91                      SWITCH_ON();
     92                      LED_ON();                          // LED闪烁，用于指示发送成功
     93                      CC1101Init(); 
     94          send:            
     95                      res = RF_SendPacket(SendBuffer, SEND_LENGTH);
     96                      if(res != 0) 
     97                      {
     98                        printf("Send ERROR:%d\r\nRetry now...\r\n", (int)res);  // 发送失败
     99                        DelayMs(10);
    100                        goto send;
    101                      }
    102                      else printf("Send OK!\r\n");              // 发送成功
    103                      
    104                      SWITCH_OFF();
    105                      LED_OFF();
    106                      Timer_30s = 1;
    107                  }
    108                  RTC_AWU_Initial(1116);     // RTC 唤醒中断    1116 * 26.95 ms = 30s
    109                  halt();//挂起，最低功耗
    110              }
    111          }
    112          
    113          // 设置TIM3的开关
    114          // sta:0，关闭   1，开启
    115          void TIM3_Set(u8 sta)
    116          {
    117              if(sta)
    118              {  
    119                  TIM3_SetCounter(0);     // 计数器清空
    120                  TIM3_ITConfig(TIM3_IT_Update,ENABLE);   // 使能TIM3更新中断
    121                  TIM3_Cmd(ENABLE);      // 使能TIM3	
    122              }
    123              else 
    124              {
    125                  TIM3_Cmd(DISABLE);     // 关闭TIM3		   
    126                  TIM3_ITConfig(TIM3_IT_Update,DISABLE);  // 关闭TIM3更新中断
    127              }
    128          }
    129          
    130          /*===========================================================================
    131          * 函数 : DelayMs() => 延时函数(ms级)                                        *
    132          * 输入 ：x, 需要延时多少(0-65535)                                             *
    133          ============================================================================*/
    134          void DelayMs(u16 x)
    135          {
    136              volatile u16 timer_ms = x;
    137              
    138              Cnt1ms = 0;
    139              TIM3_Set(1);
    140              while(Cnt1ms <= timer_ms);
    141              TIM3_Set(0);
    142          }
    143          
    144          /*===========================================================================
    145          * 函数 ：TIM3_1MS_ISR() => 定时器3服务函数, 定时时间基准为1ms               *
    146          ============================================================================*/
    147          void TIM3_1MS_ISR(void)
    148          {
    149              Cnt1ms++;
    150              
    151              if(RecvWaitTime > 0) RecvWaitTime--;    // 数据接收计时
    152          }
    153          
    154          /*===========================================================================
    155          * 函数: System_Initial() => 初始化系统所有外设                              *
    156          ============================================================================*/
    157          void System_Initial(void)
    158          {
    159              SClK_Initial();         // 初始化系统时钟，16M / 4 = 4M    
    160              GPIO_Initial();         // 初始化GPIO   LED  SWITCH
    161           
    162              USART1_Initial();       // 初始化串口1  
    163              TIM3_Initial();         // 初始化定时器3，基准1ms  
    164              SPI_Initial();          // 初始化SPI  
    165              ADC_Initial();          // 初始化ADC
    166              
    167              //RTC_Initial();          // 初始化RTC   LSI
    168              //RTC_AWU_Initial(186);     // RTC 唤醒中断    186 * 26.95 ms = 5s
    169              enableInterrupts();       // 打开总中断 
    170              
    171              U1_Set(1);
    172              printf("Oil_Can_Drone\r\n");                      // 发送字符串，末尾换行
    173          }
    174          
    175          /*===========================================================================
    176          * 函数 : BSP_RF_SendPacket() => 无线发送数据函数                            *
    177          * 输入 ：Sendbuffer指向待发送的数据，length发送数据长度                      *
    178          * 输出 ：0，发送成功                                                      
    179                   1，等待应答超时
    180                   2，数据包长度错误
    181                   3，数据包帧头错误
    182                   4，数据包源地址错误
    183                   5，数据包目标地址错误
    184                   6，数据包帧尾
    185          ============================================================================*/
    186          INT8U RF_SendPacket(INT8U *Sendbuffer, INT8U length)
    187          {
    188              uint8_t  i = 0, ack_len = 0, ack_buffer[15] = {0};
    189              RecvWaitTime = (int)RECV_TIMEOUT;           // 等待应答超时限制1500ms
    190              
    191              CC1101SendPacket(SendBuffer, length, ADDRESS_CHECK);    // 发送数据 
    192              //DelayMs(5);                       
    193              
    194              //CC1101Init();                               // 初始化L01寄存器 
    195              CC1101SetTRMode(RX_MODE);                   // 准备接收应答
    196          
    197              TIM3_Set(1);                                // 开启TIM3
    198              printf("waiting for ack...\r\n");
    199              while(CC_IRQ_READ() != 0)                   // 等待接收数据包
    200              {
    201                  if(RecvWaitTime <= 0)      
    202                  {  
    203                      TIM3_Set(0);                            // 关闭TIM3
    204                      printf("RecvWaitTime0=%d\r\n", RecvWaitTime);
    205                      return 1;                              // 等待应答超时
    206                  }
    207              }
    208              //TIM3_Set(0); 
    209              //printf("RecvWaitTime1=%d\r\n", RecvWaitTime);
    210          
    211              RecvWaitTime = 50;           // 等待应答超时限制50ms
    212              //TIM3_Set(1);                                // 开启TIM3
    213              while(CC_IRQ_READ() == 0)
    214              {
    215                  if(RecvWaitTime <= 0)      
    216                  {  
    217                      TIM3_Set(0);                            // 关闭TIM3
    218                      printf("RecvWaitTime1=%d\r\n", RecvWaitTime);
    219                      return 1;                              // 等待应答超时
    220                  }
    221              }
    222              printf("RecvWaitTime2=%d\r\n", RecvWaitTime);
    223              TIM3_Set(0);                                // 关闭TIM3
    224              ack_len = CC1101RecPacket(ack_buffer);      // 读取收到的数据
    225              
    226          //                        // 帧头  源地址  目标地址    帧尾
    227          //AckBuffer[ACK_LENGTH]   = {0x55,  0xff,     0,     0x0d, 0x0a};                                             // 主机应答数据
    228              
    229          //    if((strlen((const char*)ack_buffer) <= 0) || (strlen((const char*)ack_buffer)) > 29)  
    230          //    {
    231          //        CC1101Init(); 
    232          //        printf("ack_len0=%d\r\n", ack_len);
    233          //        return 2;                                              // 数据包长度错误
    234          //    }
    235              
    236              if(ack_len <= 0 || ack_len > 15)  
    237              {
    238                  CC1101Init(); 
    239                  printf("ack_len1=%d\r\n", ack_len);
    240                  return 2;                                          // 数据包长度错误
    241              }
    242              if(ack_len != ACK_LENGTH) return 2;                                               // 数据包长度错误
    243              if(ack_buffer[0] != 0x55) return 3;                                               // 数据包帧头错误
    244              if(ack_buffer[1] != 0xff) return 4;                                               // 数据包源地址错误       
    245              if(ack_buffer[2] == 0xff) return 5;                                               // 数据包目标地址错误
    246              if((ack_buffer[ack_len-2] != 0x0d) || (ack_buffer[ack_len-1] != 0x0a)) return 6;  // 数据包帧尾
    247          
    248              // 应答正确
    249              printf("ack_len=%d;ack_buffer:", (int)ack_len);
    250              for(i = 0; i < ack_len; i++)                     
    251              {
    252                  printf("%d ", (int)ack_buffer[i]);
    253              }
    254              printf("\r\n");
    255          
    256              return 0;  
    257          }
    258          
    259          void Get_TheTime(void)
    260          {
    261            RTC_TimeTypeDef GETRTC_Time;
    262            RTC_DateTypeDef GETRTC_Data;
    263            //unsigned char sec_st,sec_su , min_mt,min_mu ,hour_ht , hour_hu , midd ,status;
    264            if(RTC_GetFlagStatus(RTC_FLAG_RSF) == SET)  //有时间更新 
    265            {
    266              
    267              
    268              RTC_GetDate(RTC_Format_BIN , &GETRTC_Data);
    269              RTC_GetTime(RTC_Format_BIN , &GETRTC_Time);  
    270                
    271               RTC_ClearFlag(RTC_FLAG_RSF);   //清除标志
    272               printf("20%d/%d/%d Day%d %d:%d:%d\r\n" , GETRTC_Data.RTC_Year , GETRTC_Data.RTC_Month  , GETRTC_Data.RTC_Date  ,  GETRTC_Data.RTC_WeekDay ,GETRTC_Time.RTC_Hours , GETRTC_Time.RTC_Minutes , GETRTC_Time.RTC_Seconds);
    273            }
    274          }
    275          
    276          void RTC_AWU_Initial(uint16_t time)    // time * 26.95 ms 
    277          { 
    278              RTC_DeInit(); //初始化默认状态 
    279              
    280              CLK_PeripheralClockConfig(CLK_Peripheral_RTC, ENABLE);      // 允许RTC时钟 
    281              CLK_RTCClockConfig(CLK_RTCCLKSource_LSI, CLK_RTCCLKDiv_64); // 选择RTC时钟源LSI/64=593.75Hz 
    282              RTC_WakeUpClockConfig(RTC_WakeUpClock_RTCCLK_Div16);        // 593.75Hz/16=37.109375Hz t = 26.95ms 
    283              RTC_ITConfig(RTC_IT_WUT, ENABLE);  // 开启中断 
    284              RTC_SetWakeUpCounter(time);        // 设置RTC Weakup计算器初值 
    285              RTC_WakeUpCmd(ENABLE);             // 使能自动唤醒 
    286          } 
>>>>>>> origin/master

   Section sizes:

   Bytes  Function/Label
   -----  --------------
      15  ?_0
      19  ?_1
      28  ?_10
      17  ?_2
      16  ?_3
      11  ?_4
      16  ?_5
      10  ?_6
      23  ?_7
       4  ?_8
       3  ?_9
       4  AckBuffer
       2  Cnt1ms
      32  DelayMs
       1  Dis_Index
       2  Distance
      85  Get_TheTime
     150  Measured_Range
     285  RF_SendPacket
      60  RTC_AWU_Initial
       2  RecvWaitTime
       5  SendBuffer
       2  SendCnt
<<<<<<< HEAD
      36  System_Initial
=======
      38  System_Initial
>>>>>>> origin/master
      23  TIM3_1MS_ISR
       1  distance
     231  main
      36  putchar

 
<<<<<<< HEAD
 938 bytes in section .far_func.text
  10 bytes in section .near.bss
   9 bytes in section .near.data
 162 bytes in section .near.rodata
 
 938 bytes of CODE  memory
 162 bytes of CONST memory
  19 bytes of DATA  memory
=======
 894 bytes in section .far_func.text
   6 bytes in section .near.bss
  11 bytes in section .near.data
 237 bytes in section .near.rodata
 
 894 bytes of CODE  memory
 237 bytes of CONST memory
  17 bytes of DATA  memory
>>>>>>> origin/master

Errors: none
Warnings: 2
